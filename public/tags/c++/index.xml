<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on Hylu Blog</title>
    <link>http://localhost:1313/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Hylu Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 10 Jan 2024 01:02:05 -0500</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Ubisoft NEXT</title>
      <link>http://localhost:1313/posts/2024/01/ubisoft-next/</link>
      <pubDate>Wed, 10 Jan 2024 01:02:05 -0500</pubDate>
      <guid>http://localhost:1313/posts/2024/01/ubisoft-next/</guid>
      <description>Ubisoft NEXT is an annual competition run by Ubisoft that has contestants compete against a variety of disciplines within game development. From drawing art pieces, to level design, depending on your skillset you can test your abilities against others. The winner for each competition gets a 3-month internship with Ubisoft in Montreal!
I&amp;rsquo;m entering into the programming category.
Building a 3D Engine I took a look at some older submissions and noticed many of the successful projects tended towards 3D graphics.</description>
    </item>
    <item>
      <title>C&#43;&#43; Test Review</title>
      <link>http://localhost:1313/posts/2023/10/c&#43;&#43;-test-review/</link>
      <pubDate>Mon, 16 Oct 2023 13:48:23 -0400</pubDate>
      <guid>http://localhost:1313/posts/2023/10/c&#43;&#43;-test-review/</guid>
      <description>Just some scattered notes for test review.
Object Composition Object memory is stored contiguously. If an object has pointers, those pointers are still stored contiguously but point to wherever the data is.
Object Ownership One simple approach is to say that whatever creates the object becomes the owner of the object Thus, it becomes responsible for deleting it Inheritance Polymorphism Zombie* bob = new Zombie(&amp;#34;Bob&amp;#34;); Zombie* sally = new ZombieSoldier(&amp;#34;Sally&amp;#34;, 100); bob-&amp;gt;attack(); // prints &amp;#34;Bob throws a punch&amp;#34; sally-&amp;gt;attack(); // prints &amp;#34;Sally throws a punch&amp;#34; // wait.</description>
    </item>
    <item>
      <title>C&#43;&#43; A Personal Guide</title>
      <link>http://localhost:1313/posts/2023/10/c&#43;&#43;-a-personal-guide/</link>
      <pubDate>Wed, 04 Oct 2023 13:05:14 -0400</pubDate>
      <guid>http://localhost:1313/posts/2023/10/c&#43;&#43;-a-personal-guide/</guid>
      <description>A compilation of various features and gotchas I&amp;rsquo;ve encountered while studying C++.
Instantiating Object Member Variables When to Use Initializer Lists Intializer lists offer a secondary method of initializer member variables for a class. A question comes up of why would we use this method as opposed to initializing the variables on declaration of just in the constructor. Below are a few core purposes.
Initialize Const Members You could initialize these on declaration but what if you we want to pass in their values as arguments to the constructor.</description>
    </item>
    <item>
      <title>Stack and Heap</title>
      <link>http://localhost:1313/posts/2023/09/stack-and-heap/</link>
      <pubDate>Wed, 27 Sep 2023 10:08:53 -0400</pubDate>
      <guid>http://localhost:1313/posts/2023/09/stack-and-heap/</guid>
      <description>Declaring Data Structures on the Heap https://stackoverflow.com/questions/8036474/when-vectors-are-allocated-do-they-use-memory-on-the-heap-or-the-stack
vector&amp;lt;Type&amp;gt; vect; will allocate the vector, i.e. the header info, on the stack, but the elements on the free store (&amp;ldquo;heap&amp;rdquo;).
vector&amp;lt;Type&amp;gt; *vect = new vector&amp;lt;Type&amp;gt;; allocates everything on the free store (except vect pointer, which is on the stack).
vector&amp;lt;Type*&amp;gt; vect; will allocate the vector on the stack and a bunch of pointers on the free store, but where these point is determined by how you use them (you could point element 0 to the free store and element 1 to the stack, say).</description>
    </item>
    <item>
      <title>Signed Ints and Two&#39;s Complement</title>
      <link>http://localhost:1313/posts/2023/09/signed-ints/</link>
      <pubDate>Tue, 12 Sep 2023 16:56:05 -0400</pubDate>
      <guid>http://localhost:1313/posts/2023/09/signed-ints/</guid>
      <description>Two&amp;rsquo;s Complement Representation Why We Use It In c++, signed integers are represented in two&amp;rsquo;s complement notation. Before I get to how that notation works, I want to explain why we use it.
Comparing both representations, -1 would look like this
// Decimal 4294967295 // Binary Signed Int 10000000000000000000000000000001 // Two&amp;#39;s Complement Signed Int 11111111111111111111111111111111 The normal signed binary representation is pretty easily understood if you know what a sign bit is.</description>
    </item>
  </channel>
</rss>
