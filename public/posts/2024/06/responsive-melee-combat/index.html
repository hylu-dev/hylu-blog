<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Responsive Melee Combat | Hylu Blog</title>
<meta name="keywords" content="unity, gamedev">
<meta name="description" content="What is Responsive Combat Whether it&rsquo;s an attack, dodge, or block, responsive combat ensures each feels immediate and with appropriate feedback. Games like Hades got this nailed down to a tee. Attacks feel punchy with minimal delay and the player rarely feels like their fighting with the controls to get the game to do what they want. By providing precise control over the character&rsquo;s abilities, responsive combat enhances the sense of agency and satisfaction, leading to more intense and rewarding gameplay experiences.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/2024/06/responsive-melee-combat/">
<link rel="stylesheet" href="http://localhost:1313/css/custom.css">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8198515fa77a6b7ffb462312ed9ac85b9c0c3f31618c387a9779d093d86bbbac.css" integrity="sha256-gZhRX6d6a3/7RiMS7ZrIW5wMPzFhjDh6l3nQk9hru6w=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/2024/06/responsive-melee-combat/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Hylu Blog (Alt + H)">Hylu Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title">
      Responsive Melee Combat
    </h1>
    <div class="post-meta"><span title='2024-06-05 23:56:04 -0400 EDT'>June 5, 2024</span>

</div>
    
    
    
    
  </header> 
<style>
    .entry-cover img {
        height: 200px !important;
        object-fit: cover !important;
    }
</style>
<div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#what-is-responsive-combat" aria-label="What is Responsive Combat">What is Responsive Combat</a></li>
                <li>
                    <a href="#input-queuing" aria-label="Input Queuing">Input Queuing</a></li>
                <li>
                    <a href="#attack-interrupts" aria-label="Attack Interrupts">Attack Interrupts</a><ul>
                        
                <li>
                    <a href="#attack-states" aria-label="Attack States">Attack States</a></li></ul>
                </li>
                <li>
                    <a href="#top-down-melee-hitboxes" aria-label="Top-Down Melee Hitboxes">Top-Down Melee Hitboxes</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="what-is-responsive-combat">What is Responsive Combat<a hidden class="anchor" aria-hidden="true" href="#what-is-responsive-combat">#</a></h2>
<p>Whether it&rsquo;s an attack, dodge, or block, responsive combat ensures each feels immediate and with appropriate feedback. Games like <strong>Hades</strong> got this nailed down to a tee. Attacks feel punchy with minimal delay and the player rarely feels like their fighting with the controls to get the game to do what they want. By providing precise control over the character&rsquo;s abilities, responsive combat enhances the sense of agency and satisfaction, leading to more intense and rewarding gameplay experiences.</p>
<h2 id="input-queuing">Input Queuing<a hidden class="anchor" aria-hidden="true" href="#input-queuing">#</a></h2>
<p>When inputs are timing dependent, you can run into the situation where inputs don&rsquo;t register because the inherent imprecision of humans. For example, we previously talked about combo attacks where one input leads to the other. Depending on the speed of the combo there&rsquo;s a certain time window between the first and second attack where the player cannot attack. Then at the exact minute picosecond that the time windows passes, the player is able to attack.</p>
<p>Two things can happen on the second attack input:</p>
<p><strong>The player attacks late</strong></p>
<blockquote>
<p>The player will be able to attack but they&rsquo;re attacking slower than it is possible. Ideally, if you want to attack at full speed, you need to attack on the precise frame that the first attack window ends. This is incredibly difficult and unreasonable to expect from the player.</p>
</blockquote>
<p><strong>The player attacks early</strong></p>
<blockquote>
<p>Even if they&rsquo;re attacking one frame too early, the attack won&rsquo;t register as we&rsquo;re still in the time window of the first attack. Of course, the player can just input again but it&rsquo;s already disorientating to have an input not register when you expect and you&rsquo;ll likely end up back in aforementioned <em>late attack</em> situation.</p>
</blockquote>
<p>We can solve this be <strong>queuing inputs</strong>. This involves holding the player&rsquo;s input for a short timeframe so it still registers within that window. For example, let&rsquo;s say we input queue for 0.3 seconds. If we click attack 0.1s before the attack is available, then 0.1s later, the input will still be registered as we&rsquo;re still running that input by the time we can attack.</p>
<p>This fixes our issues as we&rsquo;re now giving the player a window of *<em>input forgiveness</em> where as long as they perform the input within 0.3s, they will get the full expected outcome.</p>
<blockquote>
<p>It&rsquo;s important to set the input queuing window to a reasonably low value (ex. 0.2s &lt; t &lt; .0.5s) otherwise inputs can start to feel too delayed. Imagine clicking an attack when it isn&rsquo;t available and then having it attack 2 seconds later!</p>
</blockquote>
<p>Let&rsquo;s implement general input queuing!</p>
<h2 id="attack-interrupts">Attack Interrupts<a hidden class="anchor" aria-hidden="true" href="#attack-interrupts">#</a></h2>
<p>For systems like comboing, inputs lead to some running animation that must play and will likely lock out the player from inputs. Locking out the player for some time is necessary otherwise the player would constantly skip animations and be able to sequence attacks instantaneously.</p>
<p>However, it&rsquo;s usually a bad idea to lock players in for the entirety of an animation. For example, a standard attack animation typically has the attack itself followed by some sort of <strong>follow through</strong>. This is just the animation of the player returning back to their idle state. If we force the player to wait for the whole animation, every single attack will not only take too long but also feel awkwardly seperate. Imagine taking out your sword to attack 3-times but needing to sheathe your sword between every attack.</p>
<blockquote>
<p>We could just chop off the end of the animation but you likely want to have an ending animation for single attacks or last attacks in a sequence.</p>
</blockquote>
<p>The solution is to give a window for the player to perform another action while the current action is running, effectively <em>interrupting</em> the current animation.</p>
<p>We can do this by&hellip;</p>
<h3 id="attack-states">Attack States<a hidden class="anchor" aria-hidden="true" href="#attack-states">#</a></h3>
<p>We talked about melee attacks having a <strong>strike</strong> and a <strong>follow-through</strong>, but there are other states to consider in an attack.</p>
<ul>
<li>Wind-up</li>
<li>Active</li>
<li>Wind-down (follow-through)</li>
<li>Inactive</li>
</ul>
<h2 id="top-down-melee-hitboxes">Top-Down Melee Hitboxes<a hidden class="anchor" aria-hidden="true" href="#top-down-melee-hitboxes">#</a></h2>
<p>I&rsquo;ve been continuing work on <strong>Slime Hunter</strong> which uses a top-down perspective for combat</p>


    
    
  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/unity/">Unity</a></li>
      <li><a href="http://localhost:1313/tags/gamedev/">Gamedev</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="http://localhost:1313/posts/2024/05/real-time-toon-shading/">
    <span class="title">Next »</span>
    <br>
    <span>Real Time Toon Shading in Unity</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://localhost:1313/">Hylu Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
