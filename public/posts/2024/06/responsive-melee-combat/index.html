<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Responsive Melee Combat | Hylu Blog</title>
<meta name="keywords" content="unity, gamedev">
<meta name="description" content="What is Responsive Combat Whether it&rsquo;s an attack, dodge, or block, responsive combat ensures each feels immediate and with appropriate feedback. Games like Hades got this nailed down to a tee. Attacks feel punchy with minimal delay and the player rarely feels like their fighting with the controls to get the game to do what they want. By providing precise control over the character&rsquo;s abilities, responsive combat enhances the sense of agency and satisfaction, leading to more intense and rewarding gameplay experiences.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/2024/06/responsive-melee-combat/">
<link rel="stylesheet" href="http://localhost:1313/css/custom.css">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8198515fa77a6b7ffb462312ed9ac85b9c0c3f31618c387a9779d093d86bbbac.css" integrity="sha256-gZhRX6d6a3/7RiMS7ZrIW5wMPzFhjDh6l3nQk9hru6w=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/2024/06/responsive-melee-combat/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Hylu Blog (Alt + H)">Hylu Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title">
      Responsive Melee Combat
    </h1>
    <div class="post-meta"><span title='2024-06-05 23:56:04 -0400 EDT'>June 5, 2024</span>

</div>
    
    
    
    
  </header> 
<style>
    .entry-cover img {
        height: 200px !important;
        object-fit: cover !important;
    }
</style>
<div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#what-is-responsive-combat" aria-label="What is Responsive Combat">What is Responsive Combat</a></li>
                <li>
                    <a href="#input-queuing" aria-label="Input Queuing">Input Queuing</a></li>
                <li>
                    <a href="#attack-interrupts" aria-label="Attack Interrupts">Attack Interrupts</a><ul>
                        
                <li>
                    <a href="#attack-states" aria-label="Attack States">Attack States</a></li></ul>
                </li>
                <li>
                    <a href="#stylized-melee-hitboxes" aria-label="Stylized Melee Hitboxes">Stylized Melee Hitboxes</a><ul>
                        
                <li>
                    <a href="#approach-1-convex-meshes" aria-label="Approach #1: Convex Meshes">Approach #1: Convex Meshes</a></li>
                <li>
                    <a href="#approach-2-repeated-box-curve" aria-label="Approach #2: Repeated Box Curve">Approach #2: Repeated Box Curve</a></li>
                <li>
                    <a href="#approach-3-sphere-angle-cutoff" aria-label="Approach #3: Sphere Angle Cutoff">Approach #3: Sphere Angle Cutoff</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="what-is-responsive-combat">What is Responsive Combat<a hidden class="anchor" aria-hidden="true" href="#what-is-responsive-combat">#</a></h2>
<p>Whether it&rsquo;s an attack, dodge, or block, responsive combat ensures each feels immediate and with appropriate feedback. Games like <strong>Hades</strong> got this nailed down to a tee. Attacks feel punchy with minimal delay and the player rarely feels like their fighting with the controls to get the game to do what they want. By providing precise control over the character&rsquo;s abilities, responsive combat enhances the sense of agency and satisfaction, leading to more intense and rewarding gameplay experiences.</p>
<h2 id="input-queuing">Input Queuing<a hidden class="anchor" aria-hidden="true" href="#input-queuing">#</a></h2>
<p>When inputs are timing dependent, you can run into the situation where inputs don&rsquo;t register because the inherent imprecision of humans. For example, we previously talked about combo attacks where one input leads to the other. Depending on the speed of the combo there&rsquo;s a certain time window between the first and second attack where the player cannot attack. Then at the exact minute picosecond that the time windows passes, the player is able to attack.</p>
<p>Two things can happen on the second attack input:</p>
<p><strong>The player attacks late</strong></p>
<blockquote>
<p>The player will be able to attack but they&rsquo;re attacking slower than it is possible. Ideally, if you want to attack at full speed, you need to attack on the precise frame that the first attack window ends. This is incredibly difficult and unreasonable to expect from the player.</p>
</blockquote>
<p><strong>The player attacks early</strong></p>
<blockquote>
<p>Even if they&rsquo;re attacking one frame too early, the attack won&rsquo;t register as we&rsquo;re still in the time window of the first attack. Of course, the player can just input again but it&rsquo;s already disorientating to have an input not register when you expect and you&rsquo;ll likely end up back in aforementioned <em>late attack</em> situation.</p>
</blockquote>
<p>We can solve this be <strong>queuing inputs</strong>. This involves holding the player&rsquo;s input for a short timeframe so it still registers within that window. For example, let&rsquo;s say we input queue for 0.3 seconds. If we click attack 0.1s before the attack is available, then 0.1s later, the input will still be registered as we&rsquo;re still running that input by the time we can attack.</p>
<p>This fixes our issues as we&rsquo;re now giving the player a window of *<em>input forgiveness</em> where as long as they perform the input within 0.3s, they will get the full expected outcome.</p>
<blockquote>
<p>It&rsquo;s important to set the input queuing window to a reasonably low value (ex. 0.2s &lt; t &lt; .0.5s) otherwise inputs can start to feel too delayed. Imagine clicking an attack when it isn&rsquo;t available and then having it attack 2 seconds later!</p>
</blockquote>
<p>Let&rsquo;s implement general input queuing!</p>
<p>The simplest version of input queuing involves repeating an input until it succeeds. I&rsquo;m using the new input system which typically involves hooking a callback function to the input event like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>PlayerInputActions _inputActions;
</span></span><span style="display:flex;"><span>_inputActions.Player.Attack.performed += Attack;
</span></span></code></pre></div><p>Instead of hooking the <code>Attack</code> function directly. Let&rsquo;s create a middleman function that calls <code>Attack</code> and queues it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> InputContext = UnityEngine.InputSystem.InputAction.CallbackContext; <span style="color:#75715e">// For brevity</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Action&lt;InputContext&gt; attackQueuedAction = e =&gt; QueueInput(_weaponController.Attack, e);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> QueueInput(Func&lt;InputContext, <span style="color:#66d9ef">bool</span>&gt; inputCallback, InputContext e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Queue the function</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>Technically we could just assign the lambda function directly to <code>_inputActions.Player.Attack.performed</code> to save lines. The reason we create a new <code>Action&lt;InputContext&gt;</code> is so we have a reference for later checks and if we want to remove the callback from the event.</p>
</blockquote>
<p>Remember the goal here is to keep trying the input for a short interval of time until it either succeeds or the time passes. To do this, we&rsquo;ll decide an <code>inputQueueDelay</code> to repeat an input for a specified time and repeat the input using a coroutine.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">float</span> inputQueueDelay = .<span style="color:#ae81ff">3f</span>;
</span></span><span style="display:flex;"><span>Action&lt;InputContext&gt; queuedAction;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> QueueInput(Func&lt;InputContext, <span style="color:#66d9ef">bool</span>&gt; inputCallback, InputContext e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    StartCoroutine(QueueInputCoroutine(inputCallback, e));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>IEnumerator QueueInputCoroutine(Func&lt;InputContext, <span style="color:#66d9ef">bool</span>&gt; inputCallback, InputContext e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> timer = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (timer &lt; inputQueueDelay)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        inputCallback(e)
</span></span><span style="display:flex;"><span>        timer += Time.deltaTime;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">yield</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We now have some basic input queuing setup. There&rsquo;s a still a couple more things to do. If we happen to queue inputs too quickly, we want to refresh the previous input queue rather than having two run simultaneously. Additionally, if the input succeeds, the queuing should stop otherwise we may get repeat inputs.</p>
<p>First thing we need is a way to track what inputs are currently being queued. Here I&rsquo;m using Unity&rsquo;s new input system, so I&rsquo;ll create a dictionary to keep track of what inputs we&rsquo;re currently queuing.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> Dictionary&lt;Func&lt;InputContext, <span style="color:#66d9ef">bool</span>&gt;, InputContext&gt; QueuedInputMap = <span style="color:#66d9ef">new</span> Dictionary&lt;Func&lt;InputContext, <span style="color:#66d9ef">bool</span>&gt;, InputContext&gt;();
</span></span></code></pre></div><p>Next, we&rsquo;ll add an input to the map whenever we start a new queue and replace it if it already exists. We also check if the method returns <code>true</code> to exist out early from the coroutine.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> QueueInput(Func&lt;InputContext, <span style="color:#66d9ef">bool</span>&gt; inputCallback, InputContext e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (!QueuedInputMap.ContainsKey(inputCallback))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        StartCoroutine(QueueInputCoroutine(inputCallback, e));
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        QueuedInputMap.Remove(inputCallback);
</span></span><span style="display:flex;"><span>        StartCoroutine(QueueInputCoroutine(inputCallback, e));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>IEnumerator QueueInputCoroutine(Func&lt;InputContext, <span style="color:#66d9ef">bool</span>&gt; inputCallback, InputContext e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    QueuedInputMap.Add(inputCallback, e);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> timer = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (timer &lt; inputQueueDelay)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (!QueuedInputMap.ContainsKey(inputCallback)) StopCoroutine();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (inputCallback(e))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            StopCoroutine();
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            timer += Time.deltaTime;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">yield</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    QueuedInputMap.Remove(inputCallback);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="attack-interrupts">Attack Interrupts<a hidden class="anchor" aria-hidden="true" href="#attack-interrupts">#</a></h2>
<p>For systems like comboing, inputs lead to some running animation that must play and will likely lock out the player from inputs. Locking out the player for some time is necessary otherwise the player would constantly skip animations and be able to sequence attacks instantaneously.</p>
<p>However, it&rsquo;s usually a bad idea to lock players in for the entirety of an animation. For example, a standard attack animation typically has the attack itself followed by some sort of <strong>follow through</strong>. This is just the animation of the player returning back to their idle state. If we force the player to wait for the whole animation, every single attack will not only take too long but also feel awkwardly seperate. Imagine taking out your sword to attack 3-times but needing to sheathe your sword between every attack.</p>
<blockquote>
<p>We could just chop off the end of the animation but you likely want to have an ending animation for single attacks or last attacks in a sequence.</p>
</blockquote>
<p>The solution is to give a window for the player to perform another action while the current action is running, effectively <em>interrupting</em> the current animation. In code, we can expose two function for checking whether we&rsquo;re able to interrupt and a function for actually interrupting an attack.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> IsInterruptable()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check if the attack is interruptable</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> InterruptAttack()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (IsInterruptable()) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Interrupt attack e.g. cancel animation, reset combo, etc.</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="attack-states">Attack States<a hidden class="anchor" aria-hidden="true" href="#attack-states">#</a></h3>
<p>We talked about melee attacks having different states with some states being interruptable. Let&rsquo;s codify all the states of a melee attack.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">enum</span> AttackState
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    WIND_UP,
</span></span><span style="display:flex;"><span>    ACTIVE,
</span></span><span style="display:flex;"><span>    WIND_DOWN, <span style="color:#75715e">// This state should be interruptable</span>
</span></span><span style="display:flex;"><span>    INACTIVE
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>Depending on your game, you may have more states than this like sheathing/unsheathing a weapon or maybe a charge state. This may change the later code examples but the structure should largely work.</p>
</blockquote>
<p>Now that we have states, we can assign one of these states to a variable so we know where in the attack animation we are. We can do this in multiple ways such as adding an event using the animator to or using a timer to wait for the correct intervals. I&rsquo;ll give an example of what it may look like using a <strong>Coroutine</strong> for an attack.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AttackMove</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> AnimationClip clip;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">float</span> animationOffset; <span style="color:#75715e">// When the attack starts in the animation</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">float</span> duration = <span style="color:#ae81ff">0.5f</span>; <span style="color:#75715e">// How long the attacks lasts</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Vector2 direction;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">float</span> damageMultiplier = <span style="color:#ae81ff">1.0f</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">float</span> rangeMultiplier = <span style="color:#ae81ff">1.0f</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">float</span> knockbackMultiplier = <span style="color:#ae81ff">1.0f</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> IEnumerator PerformAttack(AttackMove move) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    currentAttackState = AttackState.WIND_UP;
</span></span><span style="display:flex;"><span>    SetupAttackAnimation(move);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Start attack </span>
</span></span><span style="display:flex;"><span>    _animator.SetTrigger(attackStartTriggerHash);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">yield</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> WaitForSeconds(move.animationOffset);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    currentAttackState = AttackState.ACTIVE;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">yield</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> WaitForSeconds(move.duration);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    currentAttackState = AttackState.WIND_DOWN;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">yield</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> WaitForSeconds(move.clip.length - (move.animationOffset + move.duration));
</span></span><span style="display:flex;"><span>    currentAttackState = AttackState.INACTIVE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now that we have the states currently assigned, all we have to is to only allow an attack when we deem the current attack state to be interruptable.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> IsInterruptable()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> currentAttackState == AttackState.INACTIVE ||
</span></span><span style="display:flex;"><span>        currentAttackState == AttackState.WIND_DOWN;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> InterruptAttack()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (IsInterruptable()) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (_animator.GetCurrentAnimatorStateInfo(<span style="color:#ae81ff">0</span>).shortNameHash == attackStateHash)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            _animator.CrossFade(baseStateHash, <span style="color:#ae81ff">0.0f</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Attack()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (InterruptAttack()) {
</span></span><span style="display:flex;"><span>        StartCoroutine(PerformAttack(CurrentWeapon.attackMoves[_attackMoveIndex]));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The beauty of this system is you can freely alter when we can interrupt out of attacks for any moves. For example, in our game we have a dash move that original could only interrupt attacks during the <code>WIND_DOWN</code> state since that&rsquo;s how it worked for attacks. It turned out this felt clunky and we wanted it to be interrupted even earlier. All we had to do was write another <code>IsInterrupted</code> function for dashes that allows more states to return true and use that when checking for whether we can dash.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> IsDashInterruptable()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> currentAttackState != AttackState.WIND_UP;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="stylized-melee-hitboxes">Stylized Melee Hitboxes<a hidden class="anchor" aria-hidden="true" href="#stylized-melee-hitboxes">#</a></h2>
<p>I&rsquo;ve been continuing work on <strong>Slime Hunter</strong> which uses a top-down perspective for combat. One of the challenges with melee combat is how to deal with hitboxes for the player&rsquo;s attack. For realistic games, it&rsquo;s often enough to just attach a collider to the player&rsquo;s weapon. The problem comes with stylized combat that focuses on weapon trails to indicate hitboxes.</p>
<p>Here&rsquo;s an example from the amazing <strong>Hades 2</strong>:</p>
<p>Instead of the model of the blade impacting with the enemy, the hitbox is determined by the trail left by the weapon. There&rsquo;s a few qualities to note.</p>
<ul>
<li>It appears instantly</li>
<li>The weapon animation skips between the wind up and wind down</li>
<li>Its size is irrespective to the weapon</li>
<li>It changes between combos</li>
</ul>
<p>The classic collider approach won&rsquo;t work as the animation doesn&rsquo;t have enough frames for the collider to cover the entire curve. Additionally, we want the collider to cover an instaneous area for the whole attack rather then following a rotation.</p>
<h3 id="approach-1-convex-meshes">Approach #1: Convex Meshes<a hidden class="anchor" aria-hidden="true" href="#approach-1-convex-meshes">#</a></h3>
<h3 id="approach-2-repeated-box-curve">Approach #2: Repeated Box Curve<a hidden class="anchor" aria-hidden="true" href="#approach-2-repeated-box-curve">#</a></h3>
<p>This approach is simlilar to the convex mesh in implementation but instead of building the curve using points, we use a set of box colliders to build up the curve. We can use more boxes to get closer to the ideal curve shape.</p>
<p>The Benefits</p>
<ul>
<li>We get an overal hitbox that can get pretty close to the curve</li>
</ul>
<p>The Drawbacks</p>
<ul>
<li>Using multiple box colliders is pretty inefficient</li>
</ul>
<h3 id="approach-3-sphere-angle-cutoff">Approach #3: Sphere Angle Cutoff<a hidden class="anchor" aria-hidden="true" href="#approach-3-sphere-angle-cutoff">#</a></h3>
<p>This approach takes advantage of the fact that sphere colliders are quick and already perform most of the collision calculations that we need. Whenever we get a collision within the sphere all we need to check is that the collision happens within an angle range and (if we want) we can check the collision happens in a height range as well.</p>


    
    
  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/unity/">Unity</a></li>
      <li><a href="http://localhost:1313/tags/gamedev/">Gamedev</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="http://localhost:1313/posts/2024/05/real-time-toon-shading/">
    <span class="title">Next »</span>
    <br>
    <span>Real Time Toon Shading in Unity</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://localhost:1313/">Hylu Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
