<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Unity Custom Passes with URP | Hylu Blog</title>
<meta name="keywords" content="Unity, Code">
<meta name="description" content="I&rsquo;m documenting some of my adventures looking into the Scriptable Render Pipelines in Unity. I have the goal of creating a stylized 3D pixel-art render pipeline heavily inspired by t3ssel8r.
What is URP Cel-Shading Rendering To an Intermediate Texture During rendering passes, it&rsquo;s common to store information by rendering to a texture instead of immediately rendering to the screen. For example, if you want to just do a pass to collect depth information, you can draw that information in memory and hold on to it to reference for later usage.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/2024/05/unity-custom-render-pipeline/">
<link rel="stylesheet" href="http://localhost:1313/css/custom.css">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8198515fa77a6b7ffb462312ed9ac85b9c0c3f31618c387a9779d093d86bbbac.css" integrity="sha256-gZhRX6d6a3/7RiMS7ZrIW5wMPzFhjDh6l3nQk9hru6w=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/2024/05/unity-custom-render-pipeline/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Hylu Blog (Alt + H)">Hylu Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;Â»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title">
      Unity Custom Passes with URP
    </h1>
    <div class="post-meta"><span title='2024-05-07 12:35:27 -0400 EDT'>May 7, 2024</span>

</div>
    
    
    
    
  </header> 
<figure class="entry-cover"><a href="https://roystan.net/media/tutorials/toon-shader-demo.png" target="_blank"
            rel="noopener noreferrer"><img loading="lazy" src="https://roystan.net/media/tutorials/toon-shader-demo.png" alt=""></a>
        
</figure>
<style>
    .entry-cover img {
        height: 200px !important;
        object-fit: cover !important;
    }
</style>
<div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#what-is-urp" aria-label="What is URP">What is URP</a></li>
                <li>
                    <a href="#cel-shading" aria-label="Cel-Shading">Cel-Shading</a></li>
                <li>
                    <a href="#rendering-to-an-intermediate-texture" aria-label="Rendering To an Intermediate Texture">Rendering To an Intermediate Texture</a></li>
                <li>
                    <a href="#urp-lit-shaders" aria-label="URP Lit Shaders">URP Lit Shaders</a><ul>
                        
                <li>
                    <a href="#unlit-shader-template-in-urp" aria-label="Unlit Shader Template in URP">Unlit Shader Template in URP</a></li></ul>
                </li>
                <li>
                    <a href="#pipeline-overview" aria-label="Pipeline Overview">Pipeline Overview</a></li>
                <li>
                    <a href="#forward-rendering" aria-label="Forward Rendering">Forward Rendering</a></li>
                <li>
                    <a href="#g-buffer" aria-label="G-Buffer">G-Buffer</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>I&rsquo;m documenting some of my adventures looking into the Scriptable Render Pipelines in Unity. I have the goal of creating a stylized 3D pixel-art render pipeline heavily inspired by <a href="https://imgur.com/gallery/qwhbHQq">t3ssel8r</a>.</p>
<h2 id="what-is-urp">What is URP<a hidden class="anchor" aria-hidden="true" href="#what-is-urp">#</a></h2>
<h2 id="cel-shading">Cel-Shading<a hidden class="anchor" aria-hidden="true" href="#cel-shading">#</a></h2>
<h2 id="rendering-to-an-intermediate-texture">Rendering To an Intermediate Texture<a hidden class="anchor" aria-hidden="true" href="#rendering-to-an-intermediate-texture">#</a></h2>
<p>During rendering passes, it&rsquo;s common to store information by rendering to a texture instead of immediately rendering to the screen. For example, if you want to just do a pass to collect depth information, you can draw that information in memory and hold on to it to reference for later usage. You probably wouldn&rsquo;t want to draw normals on the screen directly and mess with the rest of your render passes.</p>
<p>In Unity you would use <a href="https://docs.unity3d.com/ScriptReference/RenderTexture.html"><code>RenderTexture</code></a> which is simply just a buffer that you can write texture information too.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>RenderTexture
</span></span></code></pre></div><p>Better yet you can use some higher-level abstractions like <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.core@17.0/api/UnityEngine.Rendering.RTHandle.html"><code>RTHandle</code></a> which provides resolution management, memory pooling, and other improvements out of the box.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>RTHandle
</span></span></code></pre></div><h2 id="urp-lit-shaders">URP Lit Shaders<a hidden class="anchor" aria-hidden="true" href="#urp-lit-shaders">#</a></h2>
<p>Reference: <a href="https://www.youtube.com/watch?v=E3i2eagy_eI">https://www.youtube.com/watch?v=E3i2eagy_eI</a></p>
<p>One of the challenges of URP shaders is that we don&rsquo;t have access to surface shaders. Surface shaders are designed to hook into Unity&rsquo;s lighting system and add an entry point for further shader calculations on top. Unfortunately for URP, the configurable rendering approach as well as support more advanced rendering features like PBR don&rsquo;t align well with the concept of surface shaders that are designed to abstract fixed rendering pipelines like BRP.</p>
<p>One solution is to use Shader Graph which Unity maintains nodes to get light information.</p>
<p>For scripts though, we&rsquo;ll have to stick with HLSL shaders and <strong>do our lighting calculation manually</strong>. Luckily, we&rsquo;re given access to a bunch more HLSL macros and functions that can help us perform calculations as well as get information like light positions.</p>
<p><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/writing-shaders-urp-basic-unlit-structure.html">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/writing-shaders-urp-basic-unlit-structure.html</a>
<a href="https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html">https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html</a></p>
<p><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/use-built-in-shader-methods-shadows.html">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/use-built-in-shader-methods-shadows.html</a></p>
<h3 id="unlit-shader-template-in-urp">Unlit Shader Template in URP<a hidden class="anchor" aria-hidden="true" href="#unlit-shader-template-in-urp">#</a></h3>
<p>The usual template you want to start with for HLSL shaders in Unity is the <strong>Unlit Shader</strong>. The annoying part is the template has a lot of unnecessary boilerplate and old references. For example, it comes baked with LOD and Fog calculations that you often end up deleting. As well as old <strong>CG</strong> references like <code>#include &quot;UnityCG.cginc&quot;</code> using methods from it like <code>UnityObjectToClipPos()</code>.</p>
<blockquote>
<p><code>UnityCG.cginc</code> is one of a few <a href="https://docs.unity3d.com/Manual/SL-BuiltinIncludes.html">standard helper scripts</a> available to include. Some of these scripts like <code>Lighting.cginc</code> are only compatibile with BRP but the scripts can largely be useful across any pipeline.  I</p>
</blockquote>
<p>URP comes with more hlsl scripts that provide comparable methods to the cginc scripts such as the one&rsquo;s in <code>SpaceTransforms.hlsl</code>. When you start including other URP shader scripts, you&rsquo;ll find they conflict with with the cginc counterparts, leading to you having to removing any references to it anyway. Some of these scripts include:</p>
<ul>
<li>Core.hlsl</li>
<li>SpaceTransforms.hlsl</li>
<li>Lighting.hlsl</li>
<li>Input.hlsl</li>
</ul>
<blockquote>
<p>In any URP project, you can find these files by searching inside the Packages folder</p>
</blockquote>
<h2 id="pipeline-overview">Pipeline Overview<a hidden class="anchor" aria-hidden="true" href="#pipeline-overview">#</a></h2>
<p>When a scene is rendered to the screen, it&rsquo;s done using a series of passes that incrementally draw each part of the scene such as the geometry, the shadows, the post-processing effects, etc.</p>
<h2 id="forward-rendering">Forward Rendering<a hidden class="anchor" aria-hidden="true" href="#forward-rendering">#</a></h2>
<p>By default, Unity</p>
<h2 id="g-buffer">G-Buffer<a hidden class="anchor" aria-hidden="true" href="#g-buffer">#</a></h2>
<p>It&rsquo;s a buffer that stores per-pixel information about the geometry in the scene.
The typical components stored in a G-buffer include:</p>
<ul>
<li>Position: Stores the world-space position of each pixel.</li>
<li>Normal: Stores the surface normal vector at each pixel.</li>
<li>Albedo: Stores the base color of the surface at each pixel.</li>
<li>Specular: Stores material properties related to surface reflection or glossiness.</li>
<li>Depth: Stores the depth information of each pixel.</li>
</ul>
<p>This is typically used in deferred rendering so lighting calculations can all be done at once at the end using the G-buffer.</p>
<p>In forward rendering, every single pixel needs to calculate each light source which results in lot&rsquo;s of recalculations of positions, normals, albedo, etc.</p>


    
    
  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/unity/">Unity</a></li>
      <li><a href="http://localhost:1313/tags/code/">Code</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/2024/05/real-time-toon-shading/">
    <span class="title">Â« Prev</span>
    <br>
    <span>Real Time Toon Shading in Unity</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/2024/05/github-basics/">
    <span class="title">Next Â»</span>
    <br>
    <span>GitHub Basics for Designers</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://localhost:1313/">Hylu Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
