<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Stack and Heap | Hylu Blog</title>
<meta name="keywords" content="c&#43;&#43;">
<meta name="description" content="Declaring Data Structures on the Heap https://stackoverflow.com/questions/8036474/when-vectors-are-allocated-do-they-use-memory-on-the-heap-or-the-stack
vector&lt;Type&gt; vect; will allocate the vector, i.e. the header info, on the stack, but the elements on the free store (&ldquo;heap&rdquo;).
vector&lt;Type&gt; *vect = new vector&lt;Type&gt;; allocates everything on the free store (except vect pointer, which is on the stack).
vector&lt;Type*&gt; vect; will allocate the vector on the stack and a bunch of pointers on the free store, but where these point is determined by how you use them (you could point element 0 to the free store and element 1 to the stack, say).">
<meta name="author" content="">
<link rel="canonical" href="https://hylog.netlify.app/posts/2023/09/stack-and-heap/">
<link rel="stylesheet" href="https://hylog.netlify.app/css/custom.css">
<link crossorigin="anonymous" href="/assets/css/stylesheet.09da9c313791d5ebcf2403d84146f32ee6d50a4d877cf3a7b6d0590761e49cf5.css" integrity="sha256-CdqcMTeR1evPJAPYQUbzLubVCk2HfPOnttBZB2HknPU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://hylog.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://hylog.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://hylog.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://hylog.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://hylog.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Stack and Heap" />
<meta property="og:description" content="Declaring Data Structures on the Heap https://stackoverflow.com/questions/8036474/when-vectors-are-allocated-do-they-use-memory-on-the-heap-or-the-stack
vector&lt;Type&gt; vect; will allocate the vector, i.e. the header info, on the stack, but the elements on the free store (&ldquo;heap&rdquo;).
vector&lt;Type&gt; *vect = new vector&lt;Type&gt;; allocates everything on the free store (except vect pointer, which is on the stack).
vector&lt;Type*&gt; vect; will allocate the vector on the stack and a bunch of pointers on the free store, but where these point is determined by how you use them (you could point element 0 to the free store and element 1 to the stack, say)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hylog.netlify.app/posts/2023/09/stack-and-heap/" />
<meta property="og:image" content="https://craftofcoding.files.wordpress.com/2015/12/stackmemory31.jpg" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-27T10:08:53-04:00" />
<meta property="article:modified_time" content="2023-09-27T10:08:53-04:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://craftofcoding.files.wordpress.com/2015/12/stackmemory31.jpg" />
<meta name="twitter:title" content="Stack and Heap"/>
<meta name="twitter:description" content="Declaring Data Structures on the Heap https://stackoverflow.com/questions/8036474/when-vectors-are-allocated-do-they-use-memory-on-the-heap-or-the-stack
vector&lt;Type&gt; vect; will allocate the vector, i.e. the header info, on the stack, but the elements on the free store (&ldquo;heap&rdquo;).
vector&lt;Type&gt; *vect = new vector&lt;Type&gt;; allocates everything on the free store (except vect pointer, which is on the stack).
vector&lt;Type*&gt; vect; will allocate the vector on the stack and a bunch of pointers on the free store, but where these point is determined by how you use them (you could point element 0 to the free store and element 1 to the stack, say)."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://hylog.netlify.app/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Stack and Heap",
      "item": "https://hylog.netlify.app/posts/2023/09/stack-and-heap/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Stack and Heap",
  "name": "Stack and Heap",
  "description": "Declaring Data Structures on the Heap https://stackoverflow.com/questions/8036474/when-vectors-are-allocated-do-they-use-memory-on-the-heap-or-the-stack\nvector\u0026lt;Type\u0026gt; vect; will allocate the vector, i.e. the header info, on the stack, but the elements on the free store (\u0026ldquo;heap\u0026rdquo;).\nvector\u0026lt;Type\u0026gt; *vect = new vector\u0026lt;Type\u0026gt;; allocates everything on the free store (except vect pointer, which is on the stack).\nvector\u0026lt;Type*\u0026gt; vect; will allocate the vector on the stack and a bunch of pointers on the free store, but where these point is determined by how you use them (you could point element 0 to the free store and element 1 to the stack, say).",
  "keywords": [
    "c++"
  ],
  "articleBody": "Declaring Data Structures on the Heap https://stackoverflow.com/questions/8036474/when-vectors-are-allocated-do-they-use-memory-on-the-heap-or-the-stack\nvector\u003cType\u003e vect; will allocate the vector, i.e. the header info, on the stack, but the elements on the free store (“heap”).\nvector\u003cType\u003e *vect = new vector\u003cType\u003e; allocates everything on the free store (except vect pointer, which is on the stack).\nvector\u003cType*\u003e vect; will allocate the vector on the stack and a bunch of pointers on the free store, but where these point is determined by how you use them (you could point element 0 to the free store and element 1 to the stack, say).\nDangling Pointers on the Heap So the idea with dangling pointers is that if you allocate a piece of memory in the heap you need a pointer to pointer to that slot of memory. That’s a given.\nint* p = new int(5); Now if you want to release that block of memory, you use the pointer to free it.\ndelete *p But there’s a problem! You now have a pointer just pointing to a random block of memory that can be used by anything. This is a dangling pointer.\nDangling Pointers on the Stack If variables go out of scope in the stack, it gets released from the stack so we don’t need to depend on delete. However we can still get the dangers of dangling pointers.\nint* DoSomething() { int x; int* p = \u0026x; return p } int* a = DoSomething(); a now points to an unused piece of memory in the stack! This is dangerous cause that memory space could be taken up by something later on and we don’t want to mess with that memory.\nDifference With Uninitialized Variables An uninitialized variable is generally a bad idea\nint x;\nIf you dereference it, you could get anything depending on whatever was left there in memory. This is not as bad as the aforementioned dangling pointer though as at least that memory block is being used by x so it won’t be used later down line until x is released.\nint x; Memory Leaks If you allocate some memory on the heap, you should always have a pointer leading to it. If you lose those pointers, than you’ll have no way of accessing that memory.\nThat is, you won’t ever be able to free that memory.\n",
  "wordCount" : "381",
  "inLanguage": "en",
  "image":"https://craftofcoding.files.wordpress.com/2015/12/stackmemory31.jpg","datePublished": "2023-09-27T10:08:53-04:00",
  "dateModified": "2023-09-27T10:08:53-04:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://hylog.netlify.app/posts/2023/09/stack-and-heap/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Hylu Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://hylog.netlify.app/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://hylog.netlify.app/" accesskey="h" title="Hylu Blog (Alt + H)">Hylu Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://hylog.netlify.app/posts/" title="Posts">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://hylog.netlify.app/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://hylog.netlify.app/">Home</a>&nbsp;»&nbsp;<a href="https://hylog.netlify.app/posts/">Posts</a></div>
    <h1 class="post-title">
      Stack and Heap
    </h1>
    <div class="post-meta"><span title='2023-09-27 10:08:53 -0400 EDT'>September 27, 2023</span>

</div>
    
    
    
    
  </header> 
<figure class="entry-cover"><a href="https://craftofcoding.files.wordpress.com/2015/12/stackmemory31.jpg" target="_blank"
            rel="noopener noreferrer"><img loading="lazy" src="https://craftofcoding.files.wordpress.com/2015/12/stackmemory31.jpg" alt=""></a>
        
</figure>
<style>
    .entry-cover img {
        height: 200px !important;
        object-fit: cover !important;
    }
</style>
<div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#declaring-data-structures-on-the-heap" aria-label="Declaring Data Structures on the Heap">Declaring Data Structures on the Heap</a></li>
                <li>
                    <a href="#dangling-pointers-on-the-heap" aria-label="Dangling Pointers on the Heap">Dangling Pointers on the Heap</a></li>
                <li>
                    <a href="#dangling-pointers-on-the-stack" aria-label="Dangling Pointers on the Stack">Dangling Pointers on the Stack</a><ul>
                        
                <li>
                    <a href="#difference-with-uninitialized-variables" aria-label="Difference With Uninitialized Variables">Difference With Uninitialized Variables</a></li></ul>
                </li>
                <li>
                    <a href="#memory-leaks" aria-label="Memory Leaks">Memory Leaks</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="declaring-data-structures-on-the-heap">Declaring Data Structures on the Heap<a hidden class="anchor" aria-hidden="true" href="#declaring-data-structures-on-the-heap">#</a></h2>
<blockquote>
<p><a href="https://stackoverflow.com/questions/8036474/when-vectors-are-allocated-do-they-use-memory-on-the-heap-or-the-stack">https://stackoverflow.com/questions/8036474/when-vectors-are-allocated-do-they-use-memory-on-the-heap-or-the-stack</a></p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span>Type<span style="color:#f92672">&gt;</span> vect;
</span></span></code></pre></div><p>will allocate the vector, i.e. the header info, on the stack, but the elements on the free store (&ldquo;heap&rdquo;).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span>Type<span style="color:#f92672">&gt;</span> <span style="color:#f92672">*</span>vect <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> vector<span style="color:#f92672">&lt;</span>Type<span style="color:#f92672">&gt;</span>;
</span></span></code></pre></div><p>allocates everything on the free store (except vect pointer, which is on the stack).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span>Type<span style="color:#f92672">*&gt;</span> vect;
</span></span></code></pre></div><p>will allocate the vector on the stack and a bunch of pointers on the free store, but where these point is determined by how you use them (you could point element 0 to the free store and element 1 to the stack, say).</p>
<h2 id="dangling-pointers-on-the-heap">Dangling Pointers on the Heap<a hidden class="anchor" aria-hidden="true" href="#dangling-pointers-on-the-heap">#</a></h2>
<p>So the idea with dangling pointers is that if you allocate a piece of memory in the heap you need a pointer to pointer to that slot of memory. That&rsquo;s a given.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p  <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">5</span>);
</span></span></code></pre></div><p>Now if you want to release that block of memory, you use the pointer to free it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">delete</span> <span style="color:#f92672">*</span>p
</span></span></code></pre></div><p>But there&rsquo;s a problem! You now have a pointer just pointing to a random block of memory that can be used by anything.
This is a <strong>dangling pointer</strong>.</p>
<h2 id="dangling-pointers-on-the-stack">Dangling Pointers on the Stack<a hidden class="anchor" aria-hidden="true" href="#dangling-pointers-on-the-stack">#</a></h2>
<p>If variables go out of scope in the stack, it gets released from the stack so we don&rsquo;t need to depend on <code>delete</code>. However we can still get the dangers of dangling pointers.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">DoSomething</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> a <span style="color:#f92672">=</span> DoSomething();
</span></span></code></pre></div><p><code>a</code> now points to an unused piece of memory in the stack! This is dangerous cause that memory space could be taken up by something later on and we don&rsquo;t want to mess with that memory.</p>
<h3 id="difference-with-uninitialized-variables">Difference With Uninitialized Variables<a hidden class="anchor" aria-hidden="true" href="#difference-with-uninitialized-variables">#</a></h3>
<p>An uninitialized variable is generally a bad idea</p>
<p><code>int x;</code></p>
<p>If you dereference it, you could get anything depending on whatever was left there in memory. This is not as bad as the aforementioned <em>dangling pointer</em> though as at least that memory block is being used by <code>x</code> so it won&rsquo;t be used later down line until <code>x</code> is released.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x;
</span></span></code></pre></div><h2 id="memory-leaks">Memory Leaks<a hidden class="anchor" aria-hidden="true" href="#memory-leaks">#</a></h2>
<p>If you allocate some memory on the heap, you should always have a pointer leading to it. If you lose those pointers, than you&rsquo;ll have no way of accessing that memory.</p>
<p>That is, <strong>you won&rsquo;t ever be able to free that memory</strong>.</p>


    
    
  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://hylog.netlify.app/tags/c&#43;&#43;/">c&#43;&#43;</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://hylog.netlify.app/posts/2023/10/pianotypes-devlog-5/">
    <span class="title">« Prev</span>
    <br>
    <span>Pianotypes Devlog 5</span>
  </a>
  <a class="next" href="https://hylog.netlify.app/posts/2023/09/useful-linear-algebra/">
    <span class="title">Next »</span>
    <br>
    <span>Useful Linear Algebra</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://hylog.netlify.app/">Hylu Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
