<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Which Way Does the UV Go? | Hylu Blog</title>
<meta name="keywords" content="glsl">
<meta name="description" content="While I was working on writing simple shape patterns in GLSL, I ended up with an interesting conundrum.
I fell into the pattern of creating shapes by closing in each side of the shape with a smoothstep in the following form.
smoothstep(-blur, &#43;blur, uv.x); In this case, this creates a vertical edge where the left side is 0 and the right side is 1. I then do the same thing for the rest of the side of the shape, until I enclose it so that all values inside the shape are 1 and everywhere else remains 0.">
<meta name="author" content="">
<link rel="canonical" href="https://hylog.netlify.app/posts/2023/old/dev/which-way-does-the-uv-go/">
<link rel="stylesheet" href="https://hylog.netlify.app/css/custom.css">
<link crossorigin="anonymous" href="/assets/css/stylesheet.09da9c313791d5ebcf2403d84146f32ee6d50a4d877cf3a7b6d0590761e49cf5.css" integrity="sha256-CdqcMTeR1evPJAPYQUbzLubVCk2HfPOnttBZB2HknPU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://hylog.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://hylog.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://hylog.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://hylog.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://hylog.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Which Way Does the UV Go?" />
<meta property="og:description" content="While I was working on writing simple shape patterns in GLSL, I ended up with an interesting conundrum.
I fell into the pattern of creating shapes by closing in each side of the shape with a smoothstep in the following form.
smoothstep(-blur, &#43;blur, uv.x); In this case, this creates a vertical edge where the left side is 0 and the right side is 1. I then do the same thing for the rest of the side of the shape, until I enclose it so that all values inside the shape are 1 and everywhere else remains 0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hylog.netlify.app/posts/2023/old/dev/which-way-does-the-uv-go/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-25T23:35:31-04:00" />
<meta property="article:modified_time" content="2023-08-25T23:35:31-04:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Which Way Does the UV Go?"/>
<meta name="twitter:description" content="While I was working on writing simple shape patterns in GLSL, I ended up with an interesting conundrum.
I fell into the pattern of creating shapes by closing in each side of the shape with a smoothstep in the following form.
smoothstep(-blur, &#43;blur, uv.x); In this case, this creates a vertical edge where the left side is 0 and the right side is 1. I then do the same thing for the rest of the side of the shape, until I enclose it so that all values inside the shape are 1 and everywhere else remains 0."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://hylog.netlify.app/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Which Way Does the UV Go?",
      "item": "https://hylog.netlify.app/posts/2023/old/dev/which-way-does-the-uv-go/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Which Way Does the UV Go?",
  "name": "Which Way Does the UV Go?",
  "description": "While I was working on writing simple shape patterns in GLSL, I ended up with an interesting conundrum.\nI fell into the pattern of creating shapes by closing in each side of the shape with a smoothstep in the following form.\nsmoothstep(-blur, +blur, uv.x); In this case, this creates a vertical edge where the left side is 0 and the right side is 1. I then do the same thing for the rest of the side of the shape, until I enclose it so that all values inside the shape are 1 and everywhere else remains 0.",
  "keywords": [
    "glsl"
  ],
  "articleBody": "While I was working on writing simple shape patterns in GLSL, I ended up with an interesting conundrum.\nI fell into the pattern of creating shapes by closing in each side of the shape with a smoothstep in the following form.\nsmoothstep(-blur, +blur, uv.x); In this case, this creates a vertical edge where the left side is 0 and the right side is 1. I then do the same thing for the rest of the side of the shape, until I enclose it so that all values inside the shape are 1 and everywhere else remains 0. For example, a square.\nfloat square(vec2 uv, float width, float height) { float blur = .005; float shape = smoothstep(-blur, +blur, uv.x); shape *= 1.-smoothstep(-blur, +blur, uv.x-width); shape *= smoothstep(-blur, +blur, uv.y); shape *= 1.-smoothstep(-blur, +blur, uv.y-height); return shape; } UV Flipping Problem This works great and the syntax is clean. The only issue is that typically, shape translation are done through adding or subtracting from the uv directly. But with this syntax, the effect is reversed.\nFor example, let’s say I wanted to draw a square, shifted 0.5 up and to the right. I’d intuitively draw one like this.\nsquare(uv + vec2(0.5, 0.5), .2, .2); The problem is that this actually shifts it down and to the left, the opposite way! The issue with binding the interpolated value with the uv, is that the edge moves in the opposite directions that the uv are moved. Of course, you can just subtract instead for a slightly more meaningful signs.\nsquare(uv - vec2(0.5, 0.5), .2, .2); But intuitively, you’d think adding a to the uv would shift the coordinates positively and therefore translate anything drawn on it positively. This isn’t a functional problem but something about it not following expectations makes me want to find another solution.\nAn Alternative If I want to achieve the shape without flipping the UV’s, then you could do away with influencing the UV and just add a position argument like this\nfloat square(vec2 uv, vec2 pos, float width, float height) { vec2 s = step(pos, uv); float blur = 0.05; s = smoothstep(pos, pos+blur, uv); s *= smoothstep(uv-width, uv-width+blur, pos); return s.x*s.y; } And then now you can sub in the position vector instead.\nFrankly, this even worse lol. It’s adds unnecessary verbosity with the additional argument just to solve a trivial issue.\nRethinking the first solution Okay after all that, maybe it’s worth rethinking the intuition of the original solution.\nfloat shape = smoothstep(-blur, +blur, uv.x); So this line makes use of smoothstep to create an edge of white and black. Remember that smoothstep has you choose an upper and lower edge and then a value to interpolate between the two. In our case, it’s really just a single edge since we just want to blur. So then the edge will occur at the time that uv.x = blur. If we subtract from the uv, then that means we need a higher uv.x value before we hit that edge, effectively moving the edge to the right. Remember, we’re not subtracting the edge, that remains the same, we are subtracting the interpolater.\nThinking about it this way is much nicer but I can’t deny I’m a wee bit unsatisfied. I’d still like the semantic understanding to be that we move the coordinates axes and the shape follows exactly but I guess that just won’t be the case if we use the uv as the interpolator.\nIn my mind, I thought the shapes were being bound to the uv but they’re really bound to the axes and the uv is just a the guy trying to find where 0 is and we’re just messing with him.\nThis is very rambly but I’ve now accepted the reality of manipulating uvs, time to back to coding.\n",
  "wordCount" : "635",
  "inLanguage": "en",
  "datePublished": "2023-08-25T23:35:31-04:00",
  "dateModified": "2023-08-25T23:35:31-04:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://hylog.netlify.app/posts/2023/old/dev/which-way-does-the-uv-go/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Hylu Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://hylog.netlify.app/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://hylog.netlify.app/" accesskey="h" title="Hylu Blog (Alt + H)">Hylu Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://hylog.netlify.app/posts/" title="Posts">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://hylog.netlify.app/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://hylog.netlify.app/">Home</a>&nbsp;»&nbsp;<a href="https://hylog.netlify.app/posts/">Posts</a></div>
    <h1 class="post-title">
      Which Way Does the UV Go?
    </h1>
    <div class="post-meta"><span title='2023-08-25 23:35:31 -0400 EDT'>August 25, 2023</span>

</div>
    
    
    
    
  </header> 
<style>
    .entry-cover img {
        height: 200px !important;
        object-fit: cover !important;
    }
</style>
<div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#uv-flipping-problem" aria-label="UV Flipping Problem">UV Flipping Problem</a></li>
                <li>
                    <a href="#an-alternative" aria-label="An Alternative">An Alternative</a></li>
                <li>
                    <a href="#rethinking-the-first-solution" aria-label="Rethinking the first solution">Rethinking the first solution</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>While I was working on writing simple shape patterns in GLSL, I ended up with an interesting conundrum.</p>
<p>I fell into the pattern of creating shapes by closing in each side of the shape with a smoothstep in the following form.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">smoothstep</span>(<span style="color:#f92672">-</span>blur, <span style="color:#f92672">+</span>blur, uv.x);
</span></span></code></pre></div><p>In this case, this creates a vertical edge where the left side is <code>0</code> and the right side is <code>1</code>. I then do the same thing for the rest of the side of the shape, until I enclose it so that all values inside the shape are <code>1</code> and everywhere else remains <code>0</code>. For example, a square.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> <span style="color:#a6e22e">square</span>(vec2 uv, <span style="color:#66d9ef">float</span> width, <span style="color:#66d9ef">float</span> height) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> blur <span style="color:#f92672">=</span> <span style="color:#ae81ff">.005</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> shape <span style="color:#f92672">=</span> <span style="color:#a6e22e">smoothstep</span>(<span style="color:#f92672">-</span>blur, <span style="color:#f92672">+</span>blur, uv.x);
</span></span><span style="display:flex;"><span>    shape <span style="color:#f92672">*=</span> <span style="color:#ae81ff">1.</span><span style="color:#f92672">-</span><span style="color:#a6e22e">smoothstep</span>(<span style="color:#f92672">-</span>blur, <span style="color:#f92672">+</span>blur, uv.x<span style="color:#f92672">-</span>width);
</span></span><span style="display:flex;"><span>    shape <span style="color:#f92672">*=</span> <span style="color:#a6e22e">smoothstep</span>(<span style="color:#f92672">-</span>blur, <span style="color:#f92672">+</span>blur, uv.y);
</span></span><span style="display:flex;"><span>    shape <span style="color:#f92672">*=</span> <span style="color:#ae81ff">1.</span><span style="color:#f92672">-</span><span style="color:#a6e22e">smoothstep</span>(<span style="color:#f92672">-</span>blur, <span style="color:#f92672">+</span>blur, uv.y<span style="color:#f92672">-</span>height);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> shape;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="uv-flipping-problem">UV Flipping Problem<a hidden class="anchor" aria-hidden="true" href="#uv-flipping-problem">#</a></h2>
<p>This works great and the syntax is clean. The only issue is that typically, shape translation are done through adding or subtracting from the <code>uv</code> directly. But with this syntax, the effect is reversed.</p>
<p>For example, let&rsquo;s say I wanted to draw a square, shifted <code>0.5</code> up and to the right. I&rsquo;d intuitively draw one like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">square</span>(uv <span style="color:#f92672">+</span> <span style="color:#a6e22e">vec2</span>(<span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.5</span>), <span style="color:#ae81ff">.2</span>, <span style="color:#ae81ff">.2</span>);
</span></span></code></pre></div><p>The problem is that this actually shifts it down and to the left, the opposite way! The issue with binding the interpolated value with the uv, is that the edge moves in the opposite directions that the uv are moved. Of course, you can just subtract instead for a slightly more meaningful signs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">square</span>(uv <span style="color:#f92672">-</span> <span style="color:#a6e22e">vec2</span>(<span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.5</span>), <span style="color:#ae81ff">.2</span>, <span style="color:#ae81ff">.2</span>);
</span></span></code></pre></div><p>But intuitively, you&rsquo;d think adding a to the uv would shift the coordinates positively and therefore translate anything drawn on it positively.
This isn&rsquo;t a functional problem but something about it not following expectations makes me want to find another solution.</p>
<h2 id="an-alternative">An Alternative<a hidden class="anchor" aria-hidden="true" href="#an-alternative">#</a></h2>
<p>If I want to achieve the shape without flipping the UV&rsquo;s, then you could do away with influencing the UV and just add a position argument like this</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> <span style="color:#a6e22e">square</span>(vec2 uv, vec2 pos, <span style="color:#66d9ef">float</span> width, <span style="color:#66d9ef">float</span> height) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vec2 s <span style="color:#f92672">=</span> <span style="color:#a6e22e">step</span>(pos, uv);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> blur <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.05</span>;
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">=</span> <span style="color:#a6e22e">smoothstep</span>(pos, pos<span style="color:#f92672">+</span>blur, uv);
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">*=</span> <span style="color:#a6e22e">smoothstep</span>(uv<span style="color:#f92672">-</span>width, uv<span style="color:#f92672">-</span>width<span style="color:#f92672">+</span>blur, pos);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> s.x<span style="color:#f92672">*</span>s.y;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And then now you can sub in the position vector instead.</p>
<p>Frankly, this even worse lol. It&rsquo;s adds unnecessary verbosity with the additional argument just to solve a trivial issue.</p>
<h2 id="rethinking-the-first-solution">Rethinking the first solution<a hidden class="anchor" aria-hidden="true" href="#rethinking-the-first-solution">#</a></h2>
<p>Okay after all that, maybe it&rsquo;s worth rethinking the intuition of the original solution.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> shape <span style="color:#f92672">=</span> <span style="color:#a6e22e">smoothstep</span>(<span style="color:#f92672">-</span>blur, <span style="color:#f92672">+</span>blur, uv.x);
</span></span></code></pre></div><p>So this line makes use of smoothstep to create an edge of white and black. Remember that smoothstep has you choose an upper and lower edge and then a value to interpolate between the two. In our case, it&rsquo;s really just a single edge since we just want to blur. So then the edge will occur at the time that <code>uv.x = blur</code>. If we subtract from the <code>uv</code>, then that means we need a higher <code>uv.x</code> value before we hit that edge, effectively moving the edge to the right. Remember, we&rsquo;re not subtracting the edge, that remains the same, we are subtracting the interpolater.</p>
<p>Thinking about it this way is much nicer but I can&rsquo;t deny I&rsquo;m a wee bit unsatisfied. I&rsquo;d still like the semantic understanding to be that we move the coordinates axes and the shape follows exactly but I guess that just won&rsquo;t be the case if we use the <code>uv</code> as the interpolator.</p>
<p>In my mind, I thought the shapes were being bound to the <code>uv</code> but they&rsquo;re really bound to the axes and the <code>uv</code> is just a the guy trying to find where 0 is and we&rsquo;re just messing with him.</p>
<p>This is very rambly but I&rsquo;ve now accepted the reality of manipulating uvs, time to back to coding.</p>


    
    
  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://hylog.netlify.app/tags/glsl/">glsl</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://hylog.netlify.app/posts/2023/old/dev/layering-colours/">
    <span class="title">« Prev</span>
    <br>
    <span>Layering Colours</span>
  </a>
  <a class="next" href="https://hylog.netlify.app/posts/2023/old/dev/pianotypes-devlog-4/">
    <span class="title">Next »</span>
    <br>
    <span>Pianotypes Devlog 4</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://hylog.netlify.app/">Hylu Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
