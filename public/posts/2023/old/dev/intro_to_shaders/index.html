<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Introduction to Unity Shaders | Hylu Blog</title>
<meta name="keywords" content="unity, shaders">
<meta name="description" content="Shaders are programs used to describe how pixels should be arranged, colored, and transformed on the screen. The simple definition extends to so many applications especially in 3D graphics in movies and games. Every computer generated prop placed in a scene is carefully designed to look a certain way, all with the help of shaders.
Shader&rsquo;s make use of the GPU to constantly run concurrent calculation on every pixel and you can decide what those calculations do through programming with languages such as HLSL and GLSL.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/2023/old/dev/intro_to_shaders/">
<link rel="stylesheet" href="http://localhost:1313/css/custom.css">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8198515fa77a6b7ffb462312ed9ac85b9c0c3f31618c387a9779d093d86bbbac.css" integrity="sha256-gZhRX6d6a3/7RiMS7ZrIW5wMPzFhjDh6l3nQk9hru6w=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/2023/old/dev/intro_to_shaders/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Hylu Blog (Alt + H)">Hylu Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title">
      Introduction to Unity Shaders
    </h1>
    <div class="post-meta"><span title='2023-05-06 13:26:32 -0400 EDT'>May 6, 2023</span>

</div>
    
    
    
    
  </header> 
<figure class="entry-cover"><a href="https://acegikmo.com/shaderforge/images/web/screenshots/sf_ss_mainpage_b.jpg" target="_blank"
            rel="noopener noreferrer"><img loading="lazy" src="https://acegikmo.com/shaderforge/images/web/screenshots/sf_ss_mainpage_b.jpg" alt=""></a>
        
</figure>
<style>
    .entry-cover img {
        height: 200px !important;
        object-fit: cover !important;
    }
</style>
<div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#how-are-they-used" aria-label="How Are They Used">How Are They Used</a></li>
                <li>
                    <a href="#the-unity-shader-file" aria-label="The Unity Shader File">The Unity Shader File</a><ul>
                        
                <li>
                    <a href="#vertex-shader" aria-label="Vertex Shader">Vertex Shader</a><ul>
                        
                <li>
                    <a href="#coordinate-systems" aria-label="Coordinate Systems">Coordinate Systems</a></li></ul>
                </li>
                <li>
                    <a href="#fragment-shader" aria-label="Fragment Shader">Fragment Shader</a></li></ul>
                </li>
                <li>
                    <a href="#unity-materials" aria-label="Unity Materials">Unity Materials</a><ul>
                        
                <li>
                    <a href="#shader-properties" aria-label="Shader Properties">Shader Properties</a></li></ul>
                </li>
                <li>
                    <a href="#code-structure-of-shaders" aria-label="Code Structure of Shaders">Code Structure of Shaders</a><ul>
                        
                <li>
                    <a href="#a-note-on-shader-optimization" aria-label="A Note on Shader Optimization">A Note on Shader Optimization</a></li></ul>
                </li>
                <li>
                    <a href="#creating-some-simple-fragment-shaders" aria-label="Creating Some Simple Fragment Shaders">Creating Some Simple Fragment Shaders</a><ul>
                        
                <li>
                    <a href="#displaying-normals-as-colours" aria-label="Displaying &lsquo;Normals&rsquo; as Colours">Displaying &lsquo;Normals&rsquo; as Colours</a></li>
                <li>
                    <a href="#repeating-patterns" aria-label="Repeating Patterns">Repeating Patterns</a></li></ul>
                </li>
                <li>
                    <a href="#blending" aria-label="Blending">Blending</a><ul>
                        
                <li>
                    <a href="#depth-buffer" aria-label="Depth Buffer">Depth Buffer</a></li></ul>
                </li>
                <li>
                    <a href="#creating-a-vertex-shader" aria-label="Creating a Vertex Shader">Creating a Vertex Shader</a></li>
                <li>
                    <a href="#texture-sampling" aria-label="Texture Sampling">Texture Sampling</a><ul>
                        
                <li>
                    <a href="#mapping-a-texture-to-world-space" aria-label="Mapping a Texture to World Space">Mapping a Texture to World Space</a></li>
                <li>
                    <a href="#texture-masking" aria-label="Texture Masking">Texture Masking</a></li>
                <li>
                    <a href="#mixing-textures" aria-label="Mixing Textures">Mixing Textures</a></li></ul>
                </li>
                <li>
                    <a href="#mipmaps" aria-label="Mipmaps">Mipmaps</a></li>
                <li>
                    <a href="#filtering" aria-label="Filtering">Filtering</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Shaders are programs used to describe how pixels should be arranged, colored, and transformed on the screen. The simple definition extends to so many applications especially in 3D graphics in movies and games. Every computer generated prop placed in a scene is carefully designed to look a certain way, all with the help of shaders.</p>
<p>Shader&rsquo;s make use of the GPU to constantly run concurrent calculation on every pixel and you can decide what those calculations do through programming with languages such as <strong>HLSL</strong> and <strong>GLSL</strong>. You can decide that very pixel should be moved slightly to the left, or that they should be slightly more saturated under certain conditions, or even that they have follow the movement of a sine curve and create waves like an animation. You might start to realize that there is a lot a math involved and there is. Specifically, the way you want to arrange pixels makes heavy use of linear algebra to orient points in space as well as creative calculus to take advantage of functions when wanting to create tailored movements and patterns.</p>
<p>Nowadays, shader graphs also exist to help abstract way some of the underlying math and allow a more approachable method of developing shaders at the cost of some control. It&rsquo;s is a fantastic tool that aids in the accessibility of shader programming as well as better visual understanding of how the flow of calculations vastly change the look of a mesh.</p>
<p>This post covers a summary of [Freya Holmér&rsquo;s course] on Shaders (<a href="https://www.youtube.com/watch?v=9WW5-0N1DsI/">https://www.youtube.com/watch?v=9WW5-0N1DsI/</a> &amp; <a href="https://www.youtube.com/watch?v=kfM-yu0iQBk/">https://www.youtube.com/watch?v=kfM-yu0iQBk/</a>). Note, that <strong>the following notes are in the context of Unity shaders</strong> as shaders across different frameworks and engines are implemented differently and thus invite differing workflows and architecture. Conceptually they will be mostly the same.</p>
<h2 id="how-are-they-used">How Are They Used<a hidden class="anchor" aria-hidden="true" href="#how-are-they-used">#</a></h2>
<p>It&rsquo;s better to talk about shaders in the context of how they&rsquo;re used which is typically starting from some material being fed into a shader and then placed onto an object.
Depending on the framework or engine that you&rsquo;re using, shader&rsquo;s can be used very differently. For instance, in Unity, your first have to start with a base material and then feed that material information into the shader to perform calculations on to get the final texture.</p>
<div class="mermaid">
flowchart LR
    subgraph Shader Lifecycle
        x("Mesh") --> s("Shader")
        y("Material") --> s
        s --> f(("Final Mesh"))
    end
</div>
<blockquote>
<p>Credits to <a href="https://navendu.me/posts/adding-diagrams-to-your-hugo-blog-with-mermaid/">Navendu</a> for the tutorial on setting up Mermaid diagrams on Hugo</p>
</blockquote>
<p>In other cases, you can directly apply a shader to an object or create the objects purely using shaders. It depends on the implementation of the graphics software but application is the same. <strong>Manipulating pixels using the GPU</strong>.</p>
<h2 id="the-unity-shader-file">The Unity Shader File<a hidden class="anchor" aria-hidden="true" href="#the-unity-shader-file">#</a></h2>
<div class="mermaid">
flowchart TB
    s(.shader)
        s --- p(Properties)
        s --- ss(SubShader)
        ss --- pa(Pass)
            pa --- v("Vertex Shader")
            pa --- f("Fragment Shader")
    sk((ShaderLab)) --> p & ss
    h((HLSL)) --> v & f
</div>
<h3 id="vertex-shader">Vertex Shader<a hidden class="anchor" aria-hidden="true" href="#vertex-shader">#</a></h3>
<p>From the <strong>Mesh</strong>, the shaders gets an overview of all the different vertices(points) that make up the 3D object and the following information for each vertex.</p>
<ul>
<li>Position Coordinates</li>
<li>Normal (Where that vertex is facing perpendicular to it&rsquo;s surface)</li>
<li>UV Coordinates</li>
<li>Vertex Color</li>
<li>More&hellip; (typically not needed)</li>
</ul>
<p>The code you then write here can them perform any mathematical manipulation of the vertex as you&rsquo;d like and <strong>the code you write will run concurrently for every vertex</strong> by your GPU. At a lower level, the vertices that the shader receives will by local to the objects origin for example it&rsquo;s position. After you perform your manipulation, it must then by converted into <strong>Clip Space</strong> to be used in the 3D world.his is also the set of vertices the fragment shader will receive. The next subsection will describe in more detail these coordinate systems.</p>
<div class="mermaid">
flowchart LR
    z("Local Space Vertices") --> x{"Vertex Manipulation"} --> c("Clip Space Coordinates") -->|sent to| v(("Fragment Shader"))
</div>
<p>In short, the job of the vertex shader is to&hellip;</p>
<ul>
<li>Manipulate the position of vertices</li>
<li>Pass data into the fragment shader (ex. altering UV coords)</li>
</ul>
<h4 id="coordinate-systems">Coordinate Systems<a hidden class="anchor" aria-hidden="true" href="#coordinate-systems">#</a></h4>
<blockquote>
<p><a href="https://learnopengl.com/Getting-started/Coordinate-Systems">https://learnopengl.com/Getting-started/Coordinate-Systems</a></p>
</blockquote>
<p>When meshes are shown onto the screen, the vertex information goes through multiple coordinate systems before it ends up mapped as a position on your screen. The shader will receive data in the first stage of these coordinate systems and will require conversion in order to understand how those vertex transformations relate to it&rsquo;s actual position in space and finally on your screen.</p>
<p>Though <strong>the following coordinate flow is what&rsquo;s used for OpenGL</strong> while Unity uses DirectX, the explanation of the differing coordinate spaces are helpful to know and relevant.</p>
<ul>
<li>Local Space - coordinates in relation to the objects origin</li>
<li>World Space - coordinates in respect to the larger environment world</li>
<li>View Space - coordinates in respect to what the camera perspective see&rsquo;s (particularly important when we compare how vastly different orthographic vs perspective camera represent space)</li>
<li>Clip Space - Normalizes the coordinates between <code>-1 and 1</code> based on the camera. Off camera view vertexes will be outside of this range and not visible on your screen.</li>
<li>Screen Space - Transforms normalized coordinates to viewport coordinates.</li>
</ul>
<p>For the purposes of Unity, what&rsquo;s important is the <strong>Local Space</strong> which is how vertices are fed into a shader and <strong>Clip Space</strong> which we can convert to using a built-in Unity API.</p>
<h3 id="fragment-shader">Fragment Shader<a hidden class="anchor" aria-hidden="true" href="#fragment-shader">#</a></h3>
<p>Here, rather than calculating per vertices, <strong>Unity will rasterize the received vertices</strong> so calculations can be done per pixel and the shader will run only on pixels visible in the clip space (between -1 and 1). This process is done behind the scenes and it known as <strong>Frustrum Culling</strong>.</p>
<blockquote>
<p>A cool side effect of this is <strong>aliasing</strong>. Imagine unity trying to figure out how to fit square pixels into the shape of a triangle face on a mesh. Some of those pixels will overlap outside the shape of the face and result in jagged edges which is what <strong>anti-aliasing</strong> serves to minimize.</p>
</blockquote>
<p>Similarly to before, all code will run concurrently for every pixel.</p>
<div class="mermaid">
flowchart LR
    z("Clip Space Vertices") --> x("Culled into Rasterized Pixels") --> c("Calculations") --> v(("Output on Screen"))
</div>
<p>In order to rasterize, an important process that happens is <strong>Barycentric Interpolation</strong>. This blends the colours of each of the vertices to make approximate the colour of pixels between vertices. Otherwise, there&rsquo;s no explicit information for Unity to know how these areas should be displayed.</p>
<p><img loading="lazy" src="images/barycentric.png" alt="Barycentric"  />
</p>
<p>The fragment shader does not receive the vertex colours but instead, all the interpolated pixel colours.</p>
<p>In short, the job of the fragment shader is to&hellip;</p>
<ul>
<li>Determine the color of each pixel</li>
</ul>
<h2 id="unity-materials">Unity Materials<a hidden class="anchor" aria-hidden="true" href="#unity-materials">#</a></h2>
<p>Shader files are always associated with material files. You never apply a pure shader file to a object but instead a material which is then associated with a shader. This way, we can use the same shader across different materials.</p>
<h3 id="shader-properties">Shader Properties<a hidden class="anchor" aria-hidden="true" href="#shader-properties">#</a></h3>
<p>You can pass information into the shader for use in calculation such as the game time or perhaps the health bar of a character. Using the health bar example, this can be useful as perhaps you want to proportion the filled amount of the health bar shown in the shader to it&rsquo;s actual game value. These properties can be set in the Material</p>
<h2 id="code-structure-of-shaders">Code Structure of Shaders<a hidden class="anchor" aria-hidden="true" href="#code-structure-of-shaders">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Shader <span style="color:#e6db74">&#34;Unlit/SimpleShader&#34;</span> {
</span></span><span style="display:flex;"><span>    Properties { <span style="color:#75715e">// input data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// _MainTex(&#34;Texture&#34;, 2D) = &#34;white&#34; {}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">_Value</span> (<span style="color:#e6db74">&#34;value&#34;</span>, Float) <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    SubShader {
</span></span><span style="display:flex;"><span>        Tags {<span style="color:#e6db74">&#34;RenderType&#34;</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Opaque&#34;</span>} <span style="color:#75715e">// allows determination of rendering properties. For the SubShader, this largely includes sorting alpha values, render queuing, etc.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        LOD <span style="color:#ae81ff">100</span> <span style="color:#75715e">// level of detail, when you have multiple subshaders, they are prioritized based on this value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        Pass {
</span></span><span style="display:flex;"><span>            Tags {} <span style="color:#75715e">// Determination of graphics properties: blending modes, stencil properties, etc.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            CGPROGRAM
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#pragma vertex vert </span><span style="color:#75715e">// tells compiler which function is vertex shader
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">#pragma fragment frag </span><span style="color:#75715e">// which function is fragment shader
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;UnityCG.cginc&#34; // adds in built-in function from unity to aid in shader writing</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">float</span> _Value; <span style="color:#75715e">// grabs from properties
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// sampler2D _MainTex; //texture stuff
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// float4 _MainTex_ST;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">struct</span> MeshData { <span style="color:#75715e">// per-vertex mesh data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// Here you can decide what information you want to get from the mesh and store it in a variable by semantically declaring the data after a :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                float4 vertex: POSITION; <span style="color:#75715e">// vertex position
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// float3 normals : NORMAL:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// float4 tangent : TANGENT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// float4 color : COLOR;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                float2 uv: TEXCOORD0; <span style="color:#75715e">// uv0 coordinates
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">//float2 uv1: TEXCOORD1; // uv0 coordinates
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">struct</span> v2f { <span style="color:#75715e">// data passed from vertex 2 frag shader
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                float2 uv: TEXCOORD0; <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                float4 vertex: SV_POSITION; <span style="color:#75715e">// clip space coord of vertex
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            };
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            v2f <span style="color:#a6e22e">vert</span>(MeshData v) {
</span></span><span style="display:flex;"><span>                v2f o;
</span></span><span style="display:flex;"><span>                o.vertex <span style="color:#f92672">=</span> <span style="color:#a6e22e">UnityObjectToClipPos</span>(v.vertex); <span style="color:#75715e">// converts local space to clip space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> o;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// ## DATA TYPES
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// bool 0 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// float (32 bit float) good for world space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// half (16 bit float) good for most things
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// fixed (low precision) -1 to 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// vectors: float4 -&gt; half4 -&gt; fixed4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// matrices: float4x4 -&gt; half4x4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            fixed4 <span style="color:#a6e22e">frag</span>(v2f i)<span style="color:#f92672">:</span> SV_Target {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">float4</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            ENDCG
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="a-note-on-shader-optimization">A Note on Shader Optimization<a hidden class="anchor" aria-hidden="true" href="#a-note-on-shader-optimization">#</a></h3>
<p>Generally, a mesh will have more pixels when rendered than vertices. It&rsquo;s usually best to do the calculations in the shader that has the least iterations. There may be more vertices than pixels in the case you have a high poly model being rendered from extremely far way. In which case after rasterization, you&rsquo;ll only have a few pixels for the fragment shader to process.</p>
<h2 id="creating-some-simple-fragment-shaders">Creating Some Simple Fragment Shaders<a hidden class="anchor" aria-hidden="true" href="#creating-some-simple-fragment-shaders">#</a></h2>
<h3 id="displaying-normals-as-colours">Displaying &lsquo;Normals&rsquo; as Colours<a hidden class="anchor" aria-hidden="true" href="#displaying-normals-as-colours">#</a></h3>
<p><img loading="lazy" src="images/normals_shader.png" alt="Normals Shaded Sphere"  />
</p>
<blockquote>
<p>Notice how the colors coorespond to the normals. The top is green as the normal on the top of the sphere is the vector <code>(0, 1, 0)</code>, therefore mapping to green as the color.</p>
</blockquote>
<p>First, we grab the normal data from the mesh</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> appdata {
</span></span><span style="display:flex;"><span>    float4 vertex : POSITION;
</span></span><span style="display:flex;"><span>    float2 uv: TEXCOORD0;
</span></span><span style="display:flex;"><span>    float3 normal : NORMAL;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Next, we assign the normals in our vertex struct to the normals we took of the mesh.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>v2f <span style="color:#a6e22e">vert</span>(appdata v) {
</span></span><span style="display:flex;"><span>    v2f o;
</span></span><span style="display:flex;"><span>    o.vertex <span style="color:#f92672">=</span> <span style="color:#a6e22e">UnityObjectToClipPos</span>(v.vertex);
</span></span><span style="display:flex;"><span>    o.normal <span style="color:#f92672">=</span> v.normal;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> o;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Then in our fragment shader, we display each pixel as a color with rgb set to the normal vector and an alpha we&rsquo;ll just set to opaque.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>float4 <span style="color:#a6e22e">frag</span>(v2f i) <span style="color:#f92672">:</span> SV_Target{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">float4</span>(i.normal, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="repeating-patterns">Repeating Patterns<a hidden class="anchor" aria-hidden="true" href="#repeating-patterns">#</a></h3>
<p>There are a litany of ways repeating patterns can be achieved and naturally so, many involve the use of wave functions.</p>
<p>To start, try feeding the uv position into a sin function and watch the results.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>float2 col <span style="color:#f92672">=</span> <span style="color:#a6e22e">sin</span>(i.uv.xy);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> <span style="color:#a6e22e">float4</span>(col.xy, col.x , <span style="color:#ae81ff">1</span>);
</span></span></code></pre></div><p>You&rsquo;ll find that there&rsquo;s virtually no difference compared to just feeding those uv coordinate to the fragment shader directly. If you think about what the <code>sin(x)</code> graph looks from 0 -&gt; 1, it doesn&rsquo;t oscillate in the range and instead only increases. To be able to see any amount of repetition, we need to increase the period. Increasing it by 2π or τ, will fit the whole first cycle into the 0 -&gt; 1 range allowing us to see the beginning of some repetition. But let&rsquo;s get several more cycles in with 6τ so we get a fuller hatching pattern instead.</p>
<p>From there, we may also want to phase-shift to get a more symmetrical pattern by having the peak of the sin wave in the center.</p>
<p>Now the hatching bars are quite blurry since there is a smooth shift between colours as the the pattern moves across the sin wave. Instead let&rsquo;s have the values round to the nearest integer with a cool trick <code>floor</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">floor</span>(x <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span>) <span style="color:#75715e">// Rounds down below .5 exclusive and rounds up above .5 inclusive.
</span></span></span></code></pre></div><p>Finally, we get this hatched shader</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>float2 col <span style="color:#f92672">=</span> <span style="color:#a6e22e">floor</span>(<span style="color:#a6e22e">sin</span>(i.uv.xy<span style="color:#f92672">*</span><span style="color:#ae81ff">6</span><span style="color:#f92672">*</span>TAU <span style="color:#f92672">-</span> PI<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">.5</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> <span style="color:#a6e22e">float4</span>(col.xy, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);
</span></span></code></pre></div><p><img loading="lazy" src="images/simple_pattern.png" alt="Simple Pattern"  />
</p>
<p>We get can even fancier and add a wiggle to the stripes. For simplicity, let&rsquo;s add the wiggle just to the horizontal stripes. Intuitively, we want to do is shift the position of the pixels along the horizontal stripe up and down in a wave pattern.</p>
<p>Let&rsquo;s start by just adding an offset to those stripes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> offset <span style="color:#f92672">=</span> i.uv.x;
</span></span><span style="display:flex;"><span>float2 col <span style="color:#f92672">=</span> <span style="color:#a6e22e">floor</span>( <span style="color:#a6e22e">cos</span>( (i.uv.xy<span style="color:#f92672">+</span>offset)<span style="color:#f92672">*</span><span style="color:#ae81ff">12</span><span style="color:#f92672">*</span>TAU)<span style="color:#f92672">*</span><span style="color:#ae81ff">.6</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">.5</span> ); <span style="color:#75715e">// I&#39;ve made some period and amplitude adjustments as well
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">return</span> <span style="color:#a6e22e">float4</span>(col.xy, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);
</span></span></code></pre></div><p>You&rsquo;ll notice that the horizontal stripes are now moving diagonally upwards because we&rsquo;re adding to them as we move left to right on the x-axis.</p>
<p>Now, it&rsquo;s as simple as adding a wave function to our offset and we&rsquo;ll get a smooth up and down wiggle to our line.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">.03</span><span style="color:#f92672">*</span><span style="color:#a6e22e">cos</span>((i.uv.x)<span style="color:#f92672">*</span><span style="color:#ae81ff">6</span><span style="color:#f92672">*</span>TAU);
</span></span><span style="display:flex;"><span>float2 col <span style="color:#f92672">=</span> <span style="color:#a6e22e">floor</span>( <span style="color:#a6e22e">cos</span>( (i.uv.xy<span style="color:#f92672">+</span>offset) <span style="color:#f92672">*</span><span style="color:#ae81ff">12</span><span style="color:#f92672">*</span>TAU) <span style="color:#f92672">*</span><span style="color:#ae81ff">.6</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">.5</span> );
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> <span style="color:#a6e22e">float4</span>(col.xy, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);
</span></span></code></pre></div><p>Similarly to the stripes themselves, I&rsquo;ve adjusted the period and amplitude to change the look of the wiggles.</p>
<p><img loading="lazy" src="images/wiggle_pattern.png" alt="Wiggle Pattern"  />
</p>
<blockquote>
<p>Notice, though I&rsquo;m only focusing on adding the wiggle to the horizontal stripes, they&rsquo;ve also influenced the period of the vertical stripes. As the wave function of the offset peaks, <strong>we&rsquo;re also phase-shifting the vertical lines</strong> which is why there are tighter grouping of vertical stripes after the peaks of the horizontal waves and bigger gaps after the dips.</p>
</blockquote>
<h2 id="blending">Blending<a hidden class="anchor" aria-hidden="true" href="#blending">#</a></h2>
<p>If you&rsquo;re familiar with blending modes in programs such as Photoshop, the theory is the same. When pixels are being layered on top of eachother, you can manipulate how pixels above interact with the pixels below. For example, you can add the values of the pixels to result in brighter colors when layering colors or multiply colors resulting in darkening (as colors as normalized between 0-1).</p>
<p>The process of blending looks like this</p>
<p><img loading="lazy" src="images/blending_equation.png" alt="Blending Equation"  />
</p>
<p>The achieve different blending effects on shaders, you will be manipulating this equation to decide how the colors defined in your shader will be effected by the colors behind it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Cull Off <span style="color:#75715e">// don&#39;t cull back or front faces (allows a transparent box to render the front and back)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ZWrite Off <span style="color:#75715e">// disable writing to depth buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ZTest LEqual <span style="color:#75715e">// &lt;default&gt; adjust render should read from depth buffer (Only render if the depth is less than or equal to)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Blend One One <span style="color:#75715e">// set blending to additive (src*1 + dst*1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Blend DstColor Zero // multiply (src*dst + dst*0)
</span></span></span></code></pre></div><h3 id="depth-buffer">Depth Buffer<a hidden class="anchor" aria-hidden="true" href="#depth-buffer">#</a></h3>
<p>When objects are in view of the camera, Unity will write its depth position from the camera as a value between 0 and 1. For other objects, their depth positions are also recorded but also compared to items already in the depth buffer. If they are behind an object, they will not render.</p>
<p>Objects that aren&rsquo;t in view can have their fragment shaders removed from the scene in order to save on resources that wouldn&rsquo;t be seen by the player anyways.</p>
<p>This can have side affects for transparency textures as you want to objects behind them to render fully in order to see the transparent objects in front them overlay their colors.</p>
<p>To remedy this, you can set Tags to notify Unity&rsquo;s renderer how they should deal with the shader</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Tags {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;RenderType&#34;</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Transparent&#34;</span> <span style="color:#75715e">// tags to inform render pipeline of the type of shader (used in things like post processing)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;Queue&#34;</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Transparent&#34;</span> <span style="color:#75715e">// adjusts draw order for transparency (render after opaque materials are rendered)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="creating-a-vertex-shader">Creating a Vertex Shader<a hidden class="anchor" aria-hidden="true" href="#creating-a-vertex-shader">#</a></h2>
<p>Now that we&rsquo;re familiar with manipulating shaders on a per pixel basis, we can start thinking about <strong>how we can apply the same process into the mesh vertices themselves</strong>. Similar to how we&rsquo;re able to create patterns using math functions, we can also render our vertices along the same math functions as well. As an example, <strong>we&rsquo;re going to create a rippling effect</strong> where the shader creates actual ripples in the mesh shape just like a drop of water onto a still lake.</p>
<p>First, let&rsquo;s create the radial wave pattern in the fragment shader and apply that knowledge later into the vertex shader.
The idea is identical to the linear striped patterns from earlier but instead of following along one of the uv components, we will get the distance vector to the center of the mesh instead.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>float4 <span style="color:#a6e22e">frag</span>(v2f i) <span style="color:#f92672">:</span> SV_Target{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> distance <span style="color:#f92672">=</span> <span style="color:#a6e22e">length</span>(<span style="color:#a6e22e">float2</span>(<span style="color:#ae81ff">.5</span>,<span style="color:#ae81ff">.5</span>)<span style="color:#f92672">-</span>uv.xy); <span style="color:#75715e">// gets distance from center
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">float</span> wave <span style="color:#f92672">=</span> <span style="color:#a6e22e">cos</span>((distance) <span style="color:#f92672">*</span> <span style="color:#ae81ff">6</span> <span style="color:#f92672">*</span> TAU <span style="color:#f92672">+</span> _Time.y);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> wave;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now that we have our pattern, we can map that function directly into our vertex shader. The only difference is that <strong>instead of assigning the wave value to a pixel color, we will now assign it as a transform to the y component of each vertex</strong>, effectively bending the mesh up an down according to the cosine wave.</p>
<p>For posterity, let&rsquo;s also just stick the wave code into its own function as well as tweaking it to look more ripple-like.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> <span style="color:#a6e22e">getWave</span>(float2 uv) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> distance <span style="color:#f92672">=</span> <span style="color:#a6e22e">length</span>(uv <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// [another way] normalize the uv coordinate from -1 to 1 with 0 as center and get distance
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">float</span> wave <span style="color:#f92672">=</span> <span style="color:#a6e22e">cos</span>((distance) <span style="color:#f92672">*</span> <span style="color:#ae81ff">6</span> <span style="color:#f92672">*</span> TAU <span style="color:#f92672">-</span> _Time.y);
</span></span><span style="display:flex;"><span>    wave <span style="color:#f92672">*=</span> _WaveAmp; <span style="color:#75715e">// property to adjust wave height in inspector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    wave <span style="color:#f92672">*=</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> distance); <span style="color:#75715e">// dissipate over distance
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> wave;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>v2f <span style="color:#a6e22e">vert</span>(appdata v) {
</span></span><span style="display:flex;"><span>    v2f o;
</span></span><span style="display:flex;"><span>    v.vertex.y <span style="color:#f92672">=</span> <span style="color:#a6e22e">getWave</span>(v.uv0);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    o.vertex <span style="color:#f92672">=</span> <span style="color:#a6e22e">UnityObjectToClipPos</span>(v.vertex);
</span></span><span style="display:flex;"><span>    o.normal <span style="color:#f92672">=</span> <span style="color:#a6e22e">mul</span>((float3x3)unity_ObjectToWorld, v.normal); <span style="color:#75715e">// UnityObjectToWorldNormal(v.normals);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    o.uv <span style="color:#f92672">=</span> (v.uv0 <span style="color:#f92672">+</span> _Offset) <span style="color:#f92672">*</span> _Scale;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> o;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>float4 <span style="color:#a6e22e">frag</span>(v2f i) <span style="color:#f92672">:</span> SV_Target{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> wave <span style="color:#f92672">=</span> <span style="color:#a6e22e">getWave</span>(i.uv)<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> wave;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And just like that, we have waves in both the pattern and shape of our plane.</p>
<p><img loading="lazy" src="images/ripple_shader.gif" alt="Ripple Shader"  />
</p>
<blockquote>
<p>With dissipation</p>
</blockquote>
<p><img loading="lazy" src="images/ripple_shader2.gif" alt="Ripple Shader2"  />
</p>
<blockquote>
<p>Without dissipation</p>
</blockquote>
<h2 id="texture-sampling">Texture Sampling<a hidden class="anchor" aria-hidden="true" href="#texture-sampling">#</a></h2>
<p>So far, we&rsquo;ve been using shaders on textureless materials but often we want to use shaders to enhance existing textures that are on materials. For example, we might have a photo-realistic mud texture that we want to apply a shader to add some bumps and dips based on the texture.</p>
<p>Compared to the previous shaders, there&rsquo;s a few new pieces of code we need to include for us to use the colour data from the current material.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Properties{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_MainTex</span>(<span style="color:#e6db74">&#34;Texture&#34;</span>, <span style="color:#ae81ff">2</span>D) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;white&#34;</span> {} <span style="color:#75715e">// pass the texture data, 2D is most common but other types like 3D exist
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// variables
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>sampler2D _Maintex; <span style="color:#75715e">// variable for texture data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>float4 _Maintex_ST; <span style="color:#75715e">// optional, holds tiling scale (_ST is a Unity semantic and automatically gives it the tiling data)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>v2f <span style="color:#a6e22e">vert</span>(appdata v) {
</span></span><span style="display:flex;"><span>    v2f o;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    o.vertex <span style="color:#f92672">=</span> <span style="color:#a6e22e">UnityObjectToClipPos</span>(v.vertex);
</span></span><span style="display:flex;"><span>    o.uv <span style="color:#f92672">=</span> <span style="color:#a6e22e">TRANSFORM_TEX</span>(v.uv, _MainTex); <span style="color:#75715e">// optional, scales the uv based on the tiling offset above
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    o.uv <span style="color:#f92672">=</span> v.uv <span style="color:#75715e">// otherwise, assigning the uv directly works the same
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> o;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>float4 <span style="color:#a6e22e">frag</span>(v2f i) <span style="color:#f92672">:</span> SV_Target{
</span></span><span style="display:flex;"><span>    fixed4 col <span style="color:#f92672">=</span> <span style="color:#a6e22e">tex2D</span>(_MainTex, i.uv); <span style="color:#75715e">// samples a color from the texture based on the uv
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> col;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="mapping-a-texture-to-world-space">Mapping a Texture to World Space<a hidden class="anchor" aria-hidden="true" href="#mapping-a-texture-to-world-space">#</a></h3>
<p>Normally, when you map a material onto a mesh, you want to link the material position strictly to the UV coordinates of the object. In some cases such as for ground textures with planes, it can be really useful to instead map those into the world. This makes it so as you move or add more objects using, they can seamlessly use the same pattern.</p>
<p>To do this, we first need to <strong>convert each vertex coordinate into its respect world coordinate</strong>. This is also an opportunity to take advantage of TEXCOORDS as we need someplace to store these coordinates so they are accessible in the fragment shader.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> v2f { 
</span></span><span style="display:flex;"><span>    float2 uv: TEXCOORD0;
</span></span><span style="display:flex;"><span>    float3 worldPos: TEXCOORD1; <span style="color:#75715e">// empty coordinates we will later use to store the converted vertex coords
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    float4 vertex: SV_POSITION;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>v2f <span style="color:#a6e22e">vert</span>(appdata v) {
</span></span><span style="display:flex;"><span>    v2f o;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    o.worldPos <span style="color:#f92672">=</span> <span style="color:#a6e22e">mul</span>(UNITY_MATRIX_M, v.vertex); <span style="color:#75715e">// converts vertex coords to world coords by multipling be Unity&#39;s model matrix
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    o.vertex <span style="color:#f92672">=</span> <span style="color:#a6e22e">UnityObjectToClipPos</span>(v.vertex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    o.uv <span style="color:#f92672">=</span> <span style="color:#a6e22e">TRANSFORM_TEX</span>(v.uv, _MainTex);
</span></span><span style="display:flex;"><span>    o.uv.x <span style="color:#f92672">+=</span> _Time.y<span style="color:#f92672">*</span><span style="color:#ae81ff">.1</span> ;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> o;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now, instead of using the UV coordinates to sample a color from the texture, we&rsquo;re going to use the world position.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>float4 <span style="color:#a6e22e">frag</span>(v2f i) <span style="color:#f92672">:</span> SV_Target{
</span></span><span style="display:flex;"><span>    float2 topDownProjection <span style="color:#f92672">=</span> i.worldPos.xz; <span style="color:#75715e">// We want to apply the texture only to the top of a flat plane so we take the x and z coordinates.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fixed4 col <span style="color:#f92672">=</span> <span style="color:#a6e22e">tex2D</span>(_MainTex, topDownProjection);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> col;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img loading="lazy" src="images/world_space_texture.gif" alt="World Space Texture"  />
</p>
<h3 id="texture-masking">Texture Masking<a hidden class="anchor" aria-hidden="true" href="#texture-masking">#</a></h3>
<p>We can also produce a masking effect by drawing another texture and using its values to mask out specific parts of our main texture. This is the same as you would do when masking textures on photoshop.</p>
<p>To begin, let&rsquo;s create a mask and play with it. We&rsquo;ll do a simple mask of black and white. This is drawn simply in Clip Studio.</p>
<p><img loading="lazy" src="images/pattern_mask.png" alt="Simple Mask"  />
</p>
<p>Create a new texture input we&rsquo;ll call <code>_MaskTex</code> and use the mask as an input.</p>
<p>To see how we can play with the values, sample the colors from the mask with our object uv and run it through a sign function to get waves of values based on the color at each pixel of the mask.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> <span style="color:#a6e22e">GetWave</span>(<span style="color:#66d9ef">float</span> coord) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> wave <span style="color:#f92672">=</span> <span style="color:#a6e22e">sin</span>( (coord <span style="color:#f92672">+</span> _Time.y)<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>TAU ); <span style="color:#75715e">// 2*TAU makes the period do two full cycles between an x input of 0-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// notice the repeating waves around transition between white and black from the original mask
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    wave <span style="color:#f92672">*=</span> coord; <span style="color:#75715e">// keeps colors that are already dark from cycling to white
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> wave;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>float4 <span style="color:#a6e22e">frag</span>(v2f i) <span style="color:#f92672">:</span> SV_Target{
</span></span><span style="display:flex;"><span>    col <span style="color:#f92672">=</span> <span style="color:#a6e22e">tex2D</span>(_MaskTex, i.uv);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">GetWave</span>(col);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img loading="lazy" src="images/mask_sampling.gif" alt="Mask Sampling"  />
</p>
<h3 id="mixing-textures">Mixing Textures<a hidden class="anchor" aria-hidden="true" href="#mixing-textures">#</a></h3>
<p>When you think of the ground texture of a surface, there&rsquo;s many component to it. There are dirt surfaces, grassy areas, rocks, and everything in between. You need a way to smoothly transition from one texture to another.</p>
<p>We can also mix between multiple textures through the use of lerp where the final parameter decides which texture to show. Instead, let&rsquo;s sub in our sample from our mask to decide between textures. With more detailed masks, you can get much more realistic transitions between different textures.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>float4 <span style="color:#a6e22e">frag</span>(v2f i) <span style="color:#f92672">:</span> SV_Target {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    float2 topDownProjection <span style="color:#f92672">=</span> i.worldPos.xz<span style="color:#f92672">/</span><span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    float4 tex0 <span style="color:#f92672">=</span> <span style="color:#a6e22e">tex2D</span>(_MainTex, topDownProjection);
</span></span><span style="display:flex;"><span>    float4 tex1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">tex2D</span>(_SecondTex, topDownProjection);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> mask <span style="color:#f92672">=</span> <span style="color:#a6e22e">tex2D</span>(_MaskTex, i.uv);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    col <span style="color:#f92672">=</span> <span style="color:#a6e22e">lerp</span>(tex0, tex1, mask);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> col;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img loading="lazy" src="images/texture_lerp.gif" alt="Texture Lerp"  />
</p>
<blockquote>
<p>We&rsquo;re still mapping the texture based on world coordinates so the textures is consistent no matter the position of the plane. Additionally, techniques such a noise are used to create better transition between textures but we remain this simple example for now.</p>
</blockquote>
<h2 id="mipmaps">Mipmaps<a hidden class="anchor" aria-hidden="true" href="#mipmaps">#</a></h2>
<p>When textures are stored in Unity, they are often converted into a series of lower and lower resolution images kept on one file. This way, when textures are shown on screen, Unity can sample from the lower resolution images based on the position of the camera from the texture to get cleaner and less noisy results.</p>
<ul>
<li>Isotropic - Stores series of smaller textures for better sampling at further distances</li>
<li>Anisotropic - Stores series of squished textures for better sampling at extreme angles</li>
</ul>
<h2 id="filtering">Filtering<a hidden class="anchor" aria-hidden="true" href="#filtering">#</a></h2>
<ul>
<li>Single - No blending between pixels (nearest neighbour)</li>
<li>Bilinear - Blends between pixels</li>
<li>Trilinear - Blends between pixels and mip levels
<ul>
<li>Sometimes lines can show up on the texture when the sampler switches mip levels, especially for low angle anisotropics</li>
</ul>
</li>
</ul>


    
    
    
<script
  type="application/javascript"
  src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"
  async
></script>
<script>
  var config = {
    startOnLoad: true,
    theme:'dark',
    align:'center',
  };
  mermaid.initialize(config);
</script>
    
  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/unity/">Unity</a></li>
      <li><a href="http://localhost:1313/tags/shaders/">Shaders</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/2023/old/dev/playing_with_glsl/">
    <span class="title">« Prev</span>
    <br>
    <span>Playing With GLSL</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/2023/old/dev/quaternion/">
    <span class="title">Next »</span>
    <br>
    <span>Understanding Quaternions</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://localhost:1313/">Hylu Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
