<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Pianotypes Devlog 5 | Hylu Blog</title>
<meta name="keywords" content="">
<meta name="description" content="I finally put a start into replacing the current ribbon visualizer implementation with an HTML canvas drawn one.
Why Bother? To reiterate, the current visualizers works by filling the screen with vertical divs that are positioned identically to the piano keys so each key essentially has a identically width column above it. I then spawn divs inside each lane that act as each of the ribbons.
The extending animation works by settings each ribbon to the max size of the lane and running a scaleY transition from 0 to 1 to mimic the ribbon growing from nothing.">
<meta name="author" content="">
<link rel="canonical" href="https://hylog.netlify.app/posts/2023/old/dev/pianotypes-devlog-5/">
<link rel="stylesheet" href="https://hylog.netlify.app/css/custom.css">
<link crossorigin="anonymous" href="/assets/css/stylesheet.09da9c313791d5ebcf2403d84146f32ee6d50a4d877cf3a7b6d0590761e49cf5.css" integrity="sha256-CdqcMTeR1evPJAPYQUbzLubVCk2HfPOnttBZB2HknPU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://hylog.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://hylog.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://hylog.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://hylog.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://hylog.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Pianotypes Devlog 5" />
<meta property="og:description" content="I finally put a start into replacing the current ribbon visualizer implementation with an HTML canvas drawn one.
Why Bother? To reiterate, the current visualizers works by filling the screen with vertical divs that are positioned identically to the piano keys so each key essentially has a identically width column above it. I then spawn divs inside each lane that act as each of the ribbons.
The extending animation works by settings each ribbon to the max size of the lane and running a scaleY transition from 0 to 1 to mimic the ribbon growing from nothing." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hylog.netlify.app/posts/2023/old/dev/pianotypes-devlog-5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-04T16:48:12-04:00" />
<meta property="article:modified_time" content="2023-09-04T16:48:12-04:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Pianotypes Devlog 5"/>
<meta name="twitter:description" content="I finally put a start into replacing the current ribbon visualizer implementation with an HTML canvas drawn one.
Why Bother? To reiterate, the current visualizers works by filling the screen with vertical divs that are positioned identically to the piano keys so each key essentially has a identically width column above it. I then spawn divs inside each lane that act as each of the ribbons.
The extending animation works by settings each ribbon to the max size of the lane and running a scaleY transition from 0 to 1 to mimic the ribbon growing from nothing."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://hylog.netlify.app/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Pianotypes Devlog 5",
      "item": "https://hylog.netlify.app/posts/2023/old/dev/pianotypes-devlog-5/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Pianotypes Devlog 5",
  "name": "Pianotypes Devlog 5",
  "description": "I finally put a start into replacing the current ribbon visualizer implementation with an HTML canvas drawn one.\nWhy Bother? To reiterate, the current visualizers works by filling the screen with vertical divs that are positioned identically to the piano keys so each key essentially has a identically width column above it. I then spawn divs inside each lane that act as each of the ribbons.\nThe extending animation works by settings each ribbon to the max size of the lane and running a scaleY transition from 0 to 1 to mimic the ribbon growing from nothing.",
  "keywords": [
    ""
  ],
  "articleBody": "I finally put a start into replacing the current ribbon visualizer implementation with an HTML canvas drawn one.\nWhy Bother? To reiterate, the current visualizers works by filling the screen with vertical divs that are positioned identically to the piano keys so each key essentially has a identically width column above it. I then spawn divs inside each lane that act as each of the ribbons.\nThe extending animation works by settings each ribbon to the max size of the lane and running a scaleY transition from 0 to 1 to mimic the ribbon growing from nothing. Once the ribbon is released, I then query the DOM object for it’s current length at that moment of the transition and then cancel the rest of the transition and manually set the div to that size. I also add a new transition that translates the ribbon from the bottom of the view until it’s offscreen where it’s then removed from the DOM.\nIt definitely works but there’s two main problems that lead to my desire for replacing with an HTML canvas.\nIt’s rather cumbersome to spawn that many DOM objects that are all styled and animating at once. I haven’t personally run into any lag issues in my testing but from a design perspective, it’s really inefficient. The current scaling transition doesn’t play well with round borders as it tries to scale those from 0 as well. This leads to a slight flicker once I end the transition and force the ribbons final size as the rounded borders snap to their final size. Another smaller reason is that I’d like to add more effects like particles which is better done with canvas anyways.\nCurrent Progress For now, I’ve just got the canvas setup and played around with creating ribbon blocks in it and animating the extension and translations of them. So far it looks great.\nMy next task is to figure out how I want to feed the key press events to the visualizer. Previously, I had a separate component for each note of the key that would just listen to keypresses for their individually note. Now, it’s just one component that needs to keep track of all notes being pressed. Additionally, since I can’t depend on the flexbox placements for the ribbon lanes, I need to notify the position of the key being pressed as well as the type of key so the canvas knows where and how to draw the ribbon.\nThough, I’m not using TypeScript, I mocked up an object type to describe the type of info the canvas will need to hold for all of the current ribbons it needs to draw.\ntype Ribbon { x: number; y: number; width: number; height: number; released: boolean; } I’m really conflicted now for how I should implement this. Even more, I’m wondering if I should rework how key press events are being handled as a whole…\nLike maybe I should just keep a single store object that tracks the most recent key event like\nexport const keyPressEvent = writable({}); And just have the piano listen to whenever this variable changes and react to it rather than what it’s doing now which is listening to a dictionary that holds the current state of every key…\n",
  "wordCount" : "544",
  "inLanguage": "en",
  "datePublished": "2023-09-04T16:48:12-04:00",
  "dateModified": "2023-09-04T16:48:12-04:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://hylog.netlify.app/posts/2023/old/dev/pianotypes-devlog-5/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Hylu Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://hylog.netlify.app/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://hylog.netlify.app/" accesskey="h" title="Hylu Blog (Alt + H)">Hylu Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://hylog.netlify.app/posts/" title="Posts">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://hylog.netlify.app/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://hylog.netlify.app/">Home</a>&nbsp;»&nbsp;<a href="https://hylog.netlify.app/posts/">Posts</a></div>
    <h1 class="post-title">
      Pianotypes Devlog 5
    </h1>
    <div class="post-meta"><span title='2023-09-04 16:48:12 -0400 EDT'>September 4, 2023</span>

</div>
    
    
    
    
  </header> 
<style>
    .entry-cover img {
        height: 200px !important;
        object-fit: cover !important;
    }
</style>
<div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#why-bother" aria-label="Why Bother?">Why Bother?</a></li>
                <li>
                    <a href="#current-progress" aria-label="Current Progress">Current Progress</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>I finally put a start into replacing the current ribbon visualizer implementation with an HTML canvas drawn one.</p>
<h2 id="why-bother">Why Bother?<a hidden class="anchor" aria-hidden="true" href="#why-bother">#</a></h2>
<p>To reiterate, the current visualizers works by filling the screen with vertical divs that are positioned identically to the piano keys so each key essentially has a identically width column above it. I then spawn divs inside each lane that act as each of the ribbons.</p>
<p>The extending animation works by settings each ribbon to the max size of the lane and running a <code>scaleY</code> transition from 0 to 1 to mimic the ribbon growing from nothing. Once the ribbon is released, I then query the DOM object for it&rsquo;s current length at that moment of the transition and then cancel the rest of the transition and manually set the div to that size. I also add a new transition that translates the ribbon from the bottom of the view until it&rsquo;s offscreen where it&rsquo;s then removed from the DOM.</p>
<p>It definitely works but there&rsquo;s two main problems that lead to my desire for replacing with an HTML canvas.</p>
<ol>
<li>It&rsquo;s rather cumbersome to spawn that many DOM objects that are all styled and animating at once. I haven&rsquo;t personally run into any lag issues in my testing but from a design perspective, it&rsquo;s really inefficient.</li>
<li>The current scaling transition doesn&rsquo;t play well with round borders as it tries to scale those from 0 as well. This leads to a slight flicker once I end the transition and force the ribbons final size as the rounded borders snap to their final size.</li>
</ol>
<p>Another smaller reason is that I&rsquo;d like to add more effects like particles which is better done with <code>canvas</code> anyways.</p>
<h2 id="current-progress">Current Progress<a hidden class="anchor" aria-hidden="true" href="#current-progress">#</a></h2>
<p>For now, I&rsquo;ve just got the canvas setup and played around with creating ribbon blocks in it and animating the extension and translations of them. So far it looks great.</p>
<p>My next task is to figure out how I want to feed the key press events to the visualizer. Previously, I had a separate component for each note of the key that would just listen to keypresses for their individually note. Now, it&rsquo;s just one component that needs to keep track of all notes being pressed. Additionally, since I can&rsquo;t depend on the flexbox placements for the ribbon lanes, I need to notify the position of the key being pressed as well as the type of key so the canvas knows where and how to draw the ribbon.</p>
<p>Though, I&rsquo;m not using TypeScript, I mocked up an object type to describe the type of info the canvas will need to hold for all of the current ribbons it needs to draw.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">type</span> <span style="color:#a6e22e">Ribbon</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">width</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">height</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">released</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">boolean</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I&rsquo;m really conflicted now for how I should implement this. Even more, I&rsquo;m wondering if I should rework how key press events are being handled as a whole&hellip;</p>
<p>Like maybe I should just keep a single store object that tracks the most recent key event like</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">keyPressEvent</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">writable</span>({});
</span></span></code></pre></div><p>And just have the piano listen to whenever this variable changes and react to it rather than what it&rsquo;s doing now which is listening to a dictionary that holds the current state of every key&hellip;</p>


    
    
  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://hylog.netlify.app/posts/2023/09/starting-the-school-year/">
    <span class="title">« Prev</span>
    <br>
    <span>Starting the School Year</span>
  </a>
  <a class="next" href="https://hylog.netlify.app/posts/2023/old/dev/layering-colours/">
    <span class="title">Next »</span>
    <br>
    <span>Layering Colours</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://hylog.netlify.app/">Hylu Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
